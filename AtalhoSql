# SQL - Conceitos com Pr√°tica

Este material √© voltado para iniciantes que desejam aprender SQL com profundidade, do absoluto zero at√© comandos intermedi√°rios e avan√ßados. Tudo com explica√ß√µes detalhadas, exemplos reais e exerc√≠cios contextualizados para uso profissional.

---

## üìò Parte 1 ‚Äì Fundamentos do SQL e comandos DDL, DML e DQL

### üîç O que √© SQL?

SQL (Structured Query Language) √© a linguagem padr√£o para trabalhar com banco de dados relacionais. Com ela voc√™ pode:

- Criar estruturas (tabelas, colunas, chaves)
- Inserir, atualizar e deletar dados
- Consultar e filtrar informa√ß√µes
- Relacionar dados entre tabelas

### üìå Tipos de comandos SQL

| Categoria | Nome | A√ß√£o principal | Exemplos |
| --- | --- | --- | --- |
| DDL | Data Definition Language | Cria√ß√£o de estrutura | CREATE, ALTER, DROP |
| DML | Data Manipulation Language | Manipular os dados | INSERT, UPDATE, DELETE |
| DQL | Data Query Language | Consulta de dados | SELECT |
| TCL | Transaction Control Language | Controle de transa√ß√µes | COMMIT, ROLLBACK |
| DCL | Data Control Language | Permiss√µes | GRANT, REVOKE |

### üß± Criando uma tabela (DDL explicada)

```sql
CREATE TABLE TB_CLIENTE (
    ClienteId INT PRIMARY KEY IDENTITY(1,1),
    Nome VARCHAR(100) NOT NULL,
    Email VARCHAR(100),
    DataCadastro DATETIME DEFAULT GETDATE()
);

```

**Explicando linha por linha:**

- `ClienteId INT`: cria a coluna que armazenar√° o n√∫mero de identifica√ß√£o do cliente.
- `PRIMARY KEY`: define que essa coluna ser√° √∫nica e obrigat√≥ria (sem repetir).
- `IDENTITY(1,1)`: o valor come√ßa em 1 e aumenta automaticamente de 1 em 1.
- `VARCHAR(100)`: permite texto de at√© 100 caracteres.
- `NOT NULL`: essa coluna √© obrigat√≥ria.
- `DEFAULT GETDATE()`: insere a data atual automaticamente.

### ‚úçÔ∏è Inserindo dados (DML)

```sql
INSERT INTO TB_CLIENTE (Nome, Email)
VALUES ('Maria da Silva', 'maria@email.com');

```

**Explicando:**

- `INSERT INTO`: indica onde voc√™ vai inserir os dados
- `(Nome, Email)`: as colunas a preencher
- `VALUES`: os valores correspondentes

### üîé Consultando dados (DQL)

```sql
SELECT * FROM TB_CLIENTE;
SELECT Nome, Email FROM TB_CLIENTE;
SELECT TOP 5 * FROM TB_CLIENTE;

```

- `SELECT *`: mostra todas as colunas da tabela
- `TOP 5`: retorna s√≥ os 5 primeiros resultados
- `WHERE`, `ORDER BY` vir√£o em partes seguintes

### üõ†Ô∏è Atualizando dados

```sql
UPDATE TB_CLIENTE
SET Email = 'novo@email.com'
WHERE ClienteId = 1;

```

- `UPDATE`: diz qual tabela atualizar
- `SET`: define o novo valor
- `WHERE`: condi√ß√£o para limitar quais linhas ser√£o alteradas

### üóëÔ∏è Deletando dados

```sql
DELETE FROM TB_CLIENTE
WHERE ClienteId = 3;

```

- `DELETE FROM`: remove dados da tabela
- `WHERE`: evita deletar todos os registros por engano

---

## üîç Parte 2 ‚Äì Consultas com Filtros Avan√ßados

### WHERE ‚Äì Filtrando registros

```sql
SELECT * FROM TB_PRODUTO WHERE Preco > 100;

```

- Retorna somente os produtos com pre√ßo maior que 100.
- Pode combinar com `AND`, `OR`, `NOT`:

```sql
SELECT * FROM TB_PRODUTO WHERE Preco > 100 AND Estoque < 50;

```

### LIKE ‚Äì Busca por peda√ßos de texto

```sql
SELECT * FROM TB_PRODUTO WHERE Nome LIKE '%camisa%';

```

- `%` significa ‚Äúqualquer coisa‚Äù (zero ou mais letras)
- Ex: '%azul' ‚Üí termina com azul | 'camisa%' ‚Üí come√ßa com camisa

### BETWEEN ‚Äì Busca por intervalo

```sql
SELECT * FROM TB_PRODUTO WHERE Preco BETWEEN 50 AND 150;

```

- Inclui os valores 50 e 150

### IN ‚Äì Busca por conjunto de valores

```sql
SELECT * FROM TB_PRODUTO WHERE ProdutoId IN (1, 2, 5);

```

- Equivalente a usar v√°rios OR juntos

### ORDER BY ‚Äì Ordenar resultados

```sql
SELECT * FROM TB_PRODUTO ORDER BY Preco DESC;

```

- `ASC`: crescente (padr√£o)
- `DESC`: decrescente

### TOP ‚Äì Limita a quantidade de resultados

```sql
SELECT TOP 3 * FROM TB_PRODUTO ORDER BY Estoque DESC;

```

---

## üîó Parte 3 ‚Äì JOINs e Relacionamentos

### INNER JOIN ‚Äì Registros que existem nas duas tabelas

```sql
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
INNER JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;

```

- Retorna apenas clientes com pedidos registrados.

### üß† Como interpretar a query?

```sql
sql
CopiarEditar
SELECT C.Nome, P.Valor

```

- Mostra o nome do cliente vindo de `TB_CLIENTE` (`C.Nome`)
- Mostra o valor do pedido vindo de `TB_PEDIDO` (`P.Valor`)

```sql
sql
CopiarEditar
FROM TB_CLIENTE C

```

- Usa `C` como apelido para `TB_CLIENTE`

```sql
sql
CopiarEditar
INNER JOIN TB_PEDIDO P

```

- Usa `P` como apelido para `TB_PEDIDO`

```sql
sql
CopiarEditar
ON C.ClienteId = P.ClienteId;

```

- Faz a liga√ß√£o entre os dois usando `ClienteId` (a chave estrangeira)

---

### üß™ Exemplo pr√°tico para entender

Imagine essas tabelas:

**TB_CLIENTE**

| ClienteId | Nome |
| --- | --- |
| 1 | Jo√£o |
| 2 | Maria |

**TB_PEDIDO**

| PedidoId | ClienteId | Valor |
| --- | --- | --- |
| 10 | 1 | 300 |
| 11 | 1 | 200 |
| 12 | 2 | 150 |

Resultado da query:

```sql
sql
CopiarEditar
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
INNER JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;

```

| Nome | Valor |
| --- | --- |
| Jo√£o | 300 |
| Jo√£o | 200 |
| Maria | 150 |

### LEFT JOIN ‚Äì Todos os da esquerda, mesmo sem correspond√™ncia

```sql
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
LEFT JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;

```

- Mostra todos os clientes, mesmo os sem pedidos (P.Valor ser√° NULL).

### RIGHT JOIN ‚Äì Todos da direita, com ou sem cliente

```sql
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
RIGHT JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;

```

### FULL JOIN ‚Äì Traz todos os dados, mesmo sem correspond√™ncia

```sql
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
FULL JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;

```

### CROSS JOIN ‚Äì Produto cartesiano (cada um com todos)

```sql
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
CROSS JOIN TB_PEDIDO P;

```

- CUIDADO: pode gerar milhares ou milh√µes de linhas

### UPDATE com JOIN

```sql
UPDATE P
SET P.Valor = P.Valor * 0.9
FROM TB_PEDIDO P
INNER JOIN TB_CLIENTE C ON P.ClienteId = C.ClienteId
WHERE C.Nome LIKE '%Jo√£o%';

```

### DELETE com JOIN

```sql
DELETE P
FROM TB_PEDIDO P
INNER JOIN TB_CLIENTE C ON P.ClienteId = C.ClienteId
WHERE C.Ativo = 0;

```

---

## üìä Parte 4 ‚Äì Agrega√ß√µes com GROUP BY, SUM, AVG, COUNT, HAVING

### SUM ‚Äì Soma valores

```sql
SELECT ClienteId, SUM(Valor) AS TotalGasto
FROM TB_PEDIDO
GROUP BY ClienteId;

```

### AVG ‚Äì M√©dia de valores

```sql
SELECT ClienteId, AVG(Valor) AS MediaGasto
FROM TB_PEDIDO
GROUP BY ClienteId;

```

### COUNT ‚Äì Contar quantos registros

```sql
SELECT ClienteId, COUNT(*) AS TotalPedidos
FROM TB_PEDIDO
GROUP BY ClienteId;

```

### MIN / MAX ‚Äì Valor m√≠nimo ou m√°ximo

```sql
SELECT ClienteId, MIN(Valor) AS MenorPedido, MAX(Valor) AS MaiorPedido
FROM TB_PEDIDO
GROUP BY ClienteId;

```

### HAVING ‚Äì Filtro para agrega√ß√µes (como WHERE, mas ap√≥s o GROUP BY)

```sql
SELECT ClienteId, SUM(Valor) AS TotalGasto
FROM TB_PEDIDO
GROUP BY ClienteId
HAVING SUM(Valor) > 500;

```

- WHERE filtra linhas antes do GROUP BY
- HAVING filtra resultados agregados

---

## üß™ Desafios e Exerc√≠cios Pr√°ticos

1. Liste todos os clientes com nome, total de pedidos e valor m√©dio por pedido.
2. Mostre os 3 clientes que mais gastaram em pedidos.
3. Liste todos os pedidos realizados em 2024 e o total mensal (usar `GROUP BY MONTH(DataPedido)`).
4. Mostre os produtos com estoque abaixo da m√©dia (usar subquery com AVG).
5. Liste os clientes que n√£o fizeram nenhum pedido (usar LEFT JOIN e WHERE P.PedidoId IS NULL).

---

Esse conte√∫do √© constru√≠do para te levar da base at√© a aplica√ß√£o pr√°tica, com foco no ambiente corporativo e uso profissional.

## üîó Parte 3 ‚Äì JOINs e Relacionamentos (Aprofundado)

### üîç O que √© JOIN?

JOIN √© o mecanismo que o SQL oferece para **ligar dados entre tabelas** usando colunas que se relacionam. Ele √© fundamental em bancos relacionais porque permite que voc√™ trabalhe com dados distribu√≠dos em tabelas diferentes de forma eficiente.

---

### üß† INNER JOIN ‚Äì Retorna apenas os dados que t√™m correspond√™ncia nas duas tabelas

```
SELECT C.Nome, P.Valor, P.DataPedido
FROM TB_CLIENTE C
INNER JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;
```

**Explica√ß√£o:**

- S√≥ ser√£o retornados clientes que fizeram ao menos um pedido.
- Se o cliente existir, mas n√£o tiver pedido, ele ser√° ignorado.

**Visualiza√ß√£o l√≥gica:**

```
[TABELA CLIENTE] + [TABELA PEDIDO] => S√≥ onde existe correspond√™ncia de ClienteId
```

---

### üß† LEFT JOIN ‚Äì Traz todos os dados da tabela da esquerda

```
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
LEFT JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;
```

**Explica√ß√£o:**

- Todos os clientes aparecer√£o.
- Se algum cliente n√£o tiver pedido, os campos de pedido vir√£o como `NULL`.
- Muito usado para encontrar ‚Äúquem est√° faltando‚Äù.

---

### üß† RIGHT JOIN ‚Äì O inverso do LEFT JOIN

```
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
RIGHT JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;
```

**Explica√ß√£o:**

- Todos os pedidos ser√£o retornados.
- Clientes que n√£o existem mais mas ainda t√™m registros na tabela de pedidos (casos de inconsist√™ncia) ainda aparecer√£o.

---

### üß† FULL OUTER JOIN ‚Äì Junta tudo das duas tabelas

```
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
FULL OUTER JOIN TB_PEDIDO P ON C.ClienteId = P.ClienteId;
```

**Explica√ß√£o:**

- Mostra todos os clientes e todos os pedidos, mesmo que n√£o tenham correspond√™ncia.
- Ideal para auditorias.

---

### üß† CROSS JOIN ‚Äì Produto cartesiano

```
SELECT C.Nome, P.Valor
FROM TB_CLIENTE C
CROSS JOIN TB_PEDIDO P;
```

**Explica√ß√£o:**

- Junta cada linha de uma tabela com todas da outra.
- Pode explodir a quantidade de registros. Use com muito cuidado.

---

### üîÑ UPDATE com JOIN

```
UPDATE P
SET P.Valor = P.Valor * 0.9
FROM TB_PEDIDO P
INNER JOIN TB_CLIENTE C ON P.ClienteId = C.ClienteId
WHERE C.Nome LIKE '%Jo√£o%';
```

**Explica√ß√£o:**

- Aplica 10% de desconto nos pedidos feitos por clientes cujo nome cont√©m ‚ÄúJo√£o‚Äù.
- `FROM` com `JOIN` √© necess√°rio no SQL Server para fazer UPDATE com dados de outra tabela.

---

### üóëÔ∏è DELETE com JOIN

```
DELETE P
FROM TB_PEDIDO P
INNER JOIN TB_CLIENTE C ON P.ClienteId = C.ClienteId
WHERE C.Ativo = 0;
```

**Explica√ß√£o:**

- Remove todos os pedidos de clientes inativos.
- Ideal para manuten√ß√µes e limpezas.

---

## üìä Parte 4 ‚Äì Fun√ß√µes de Agrega√ß√£o e Agrupamento (Aprofundado)

### üß† Por que usar GROUP BY?

O `GROUP BY` permite agrupar dados que t√™m algo em comum e aplicar fun√ß√µes como `SUM`, `AVG`, `COUNT`, etc.

Ele √© essencial para gerar relat√≥rios, KPIs e dashboards em SQL.

---

### üî¢ SUM ‚Äì Somar valores

```
SELECT ClienteId, SUM(Valor) AS TotalGasto
FROM TB_PEDIDO
GROUP BY ClienteId;
```

**Explica√ß√£o:**

- Agrupa por cliente.
- Soma o valor total gasto por cada um.

---

### üéØ AVG ‚Äì M√©dia dos valores

```
SELECT ClienteId, AVG(Valor) AS MediaPedidos
FROM TB_PEDIDO
GROUP BY ClienteId;
```

**Explica√ß√£o:**

- M√©dia dos valores por cliente.

---

### üî¢ COUNT ‚Äì Contar registros

```
SELECT ClienteId, COUNT(*) AS QtdePedidos
FROM TB_PEDIDO
GROUP BY ClienteId;
```

**Explica√ß√£o:**

- Quantos pedidos cada cliente fez.

---

### üìâ MIN / MAX ‚Äì Menor e maior valores

```
SELECT ClienteId, MIN(Valor) AS PedidoMaisBarato, MAX(Valor) AS PedidoMaisCaro
FROM TB_PEDIDO
GROUP BY ClienteId;
```

---

### üîç HAVING ‚Äì Filtro ap√≥s agrupamento

```
SELECT ClienteId, SUM(Valor) AS TotalGasto
FROM TB_PEDIDO
GROUP BY ClienteId
HAVING SUM(Valor) > 500;
```

**Explica√ß√£o:**

- O `WHERE` funciona antes do agrupamento.
- O `HAVING` filtra depois da agrega√ß√£o.

---

###
