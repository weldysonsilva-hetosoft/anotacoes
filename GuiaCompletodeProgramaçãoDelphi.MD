# üìö Guia Completo de Programa√ß√£o Delphi para o [Sol.NE](http://sol.net/)T

## üéØ Sobre Este Guia

Este documento foi criado para desenvolvedores iniciantes e j√∫niores que est√£o come√ßando a trabalhar com o sistema [Sol.NET](http://sol.net/). Aqui voc√™ encontrar√° explica√ß√µes detalhadas sobre os conceitos fundamentais de programa√ß√£o em Delphi, com exemplos pr√°ticos extra√≠dos do pr√≥prio c√≥digo do [Sol.NET](http://sol.net/).

---

## üìë √çndice

Claro! Aqui est√° o √≠ndice com todos os links atualizados para apontarem para o reposit√≥rio do GitHub:

---

## üìë √çndice

1. [Vari√°veis e Constantes](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
2. [Operadores](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
3. [Estruturas de Decis√£o](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
4. [Estruturas de Repeti√ß√£o (Loops)](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
5. [Fun√ß√µes e Procedimentos](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
6. [Trabalhando com Strings](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
7. [Arrays , Listas e Matriz](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
8. [Classes e Objetos](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
9. [Construtores e Destrutores](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
10. [Encapsulamento](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
11. [Heran√ßa](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
12. [Polimorfismo](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
13. [Classes Abstratas e Interfaces](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
14.[Cliente Data Set](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)  
15. [Boas Pr√°ticas no Sol.NET](https://github.com/weldysonsilva-hetosoft/anotacoes/edit/main/GuiaCompletodePrograma%C3%A7%C3%A3oDelphi.MD)

---

Se quiser, posso tamb√©m formatar esse √≠ndice em Markdown para facilitar a edi√ß√£o no GitHub. Deseja isso?


---

## 1. Vari√°veis e Constantes

### 1.1 Defini√ß√£o de Escopo

O **escopo** determina onde uma vari√°vel pode ser acessada no c√≥digo.

### Escopo Local

Vari√°veis declaradas dentro de um procedimento/fun√ß√£o s√≥ existem dentro dele.

```
procedure ExemploEscopoLocal;
begin
  var MinhaVariavel: Integer := 10; // Existe apenas dentro deste procedimento
  ShowMessage(MinhaVariavel.ToString);
end; // MinhaVariavel deixa de existir aqui

```

### Escopo Global (Campos de Classe)

Vari√°veis declaradas na se√ß√£o `private`, `protected` ou `public` de uma classe.

```
type
  TFrmConversao = class(TForm)
  private
    FNomeIntegracao: string; // Campo privado - acess√≠vel em toda a classe
    FDados: TDados;
  public
    property NomeIntegracao: string read FNomeIntegracao write FNomeIntegracao;
  end;

```

**Exemplo do [Sol.NET](http://sol.net/):**

```
// Em uFrmConversao.pas
type
  TFrmConversao = class(TForm)
  private
    FConexaoOrigem: TConexao;
    FConexaoDestino: TConexao;
    FControleUtilitarios: TControleUtilitarios;
  public
    procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao);
  end;

```

### 1.2 Tipos Mais Comuns

| Tipo | Descri√ß√£o | Exemplo |
| --- | --- | --- |
| `Integer` | N√∫meros inteiros (-2.147.483.648 a 2.147.483.647) | `var Idade: Integer := 25;` |
| `Double` | N√∫meros decimais | `var Preco: Double := 10.50;` |
| `String` | Texto | `var Nome: string := 'Jo√£o';` |
| `Boolean` | Verdadeiro ou Falso | `var Ativo: Boolean := True;` |
| `TDateTime` | Data e hora | `var DataAtual: TDateTime := Now;` |
| `Currency` | Valores monet√°rios | `var ValorTotal: Currency := 1500.75;` |

### 1.3 Declarando Vari√°veis (Padr√£o Inline)

No [Sol.NET](http://sol.net/), seguimos a conven√ß√£o de **declara√ß√£o inline** do Delphi 12.2:

```
// ‚úÖ CORRETO - Padr√£o Sol.NET
procedure ProcessarPedido;
begin
  var IdPedido: Integer := 1001;
  var NomeCliente: string := 'Maria Silva';
  var ValorTotal: Double := 0.0;
  var DataPedido: TDateTime := Now;

  // C√≥digo de processamento...
end;

```

```
// ‚ùå EVITAR - Padr√£o antigo
procedure ProcessarPedido;
var
  IdPedido: Integer;
  NomeCliente: string;
  ValorTotal: Double;
begin
  IdPedido := 1001;
  NomeCliente := 'Maria Silva';
  // ...
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
function TBaseBuilder<T>.AddCampo(
  const CampoDestino, CampoOrigem: string;
  TabelaBuscar: ITabelaConversao;
  const BuscarDinamico, Apelido: string;
  ExecutarFuncoes: TArray<TFuncoes>
): IParametroSQL<T>;
begin
  var Campo: TCamposConversao := TCamposConversao.Create;
  Campo.CampoDestino := CampoDestino;
  Campo.CampoOrigem := CampoOrigem;
  Campo.TabelaBuscar := TabelaBuscar;
  Campo.BuscarDinamico := BuscarDinamico;
  Campo.Apelido := Apelido;
  Campo.ExecutarFuncoes := ExecutarFuncoes;

  FParametroSQLAtual.ListaCampos.Add(Campo);
  Result := Self;
end;

```

### 1.4 Declarando Constantes

Constantes s√£o valores que n√£o podem ser alterados durante a execu√ß√£o.

```
const
  TAXA_PADRAO: Double = 0.05;
  NOME_SISTEMA: string = 'Sol.NET';
  VERSAO_MINIMA: Integer = 12;
  DIAS_SEMANA: array[0..6] of string = (
    'Domingo', 'Segunda', 'Ter√ßa', 'Quarta',
    'Quinta', 'Sexta', 'S√°bado'
  );

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Constantes de tipos de integra√ß√£o fiscal
const
  TIPO_SCHMITT = 'Schmitt';
  TIPO_IMENDES = 'IMendes';
  TIPO_MIXFISCAL = 'MixFiscal';

```

### 1.5 Declarando Arrays

### Array Est√°tico

```
var Notas: array[0..3] of Double := [7.5, 8.0, 9.2, 6.8];
var Nomes: array[0..2] of string := ['Ana', 'Bruno', 'Carlos'];

```

### Array Din√¢mico

```
var ListaIds: TArray<Integer>;
begin
  SetLength(ListaIds, 5);
  ListaIds[0] := 100;
  ListaIds[1] := 200;
  // ...
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em Integracao.Tipos.pas
type
  TArray<TFuncoes> = array of TFuncoes; // Array din√¢mico de fun√ß√µes

// Uso:
Campo.ExecutarFuncoes := [TFuncoes.SoNumeros, TFuncoes.Maiuscula];

```

---

## 2. Operadores

### 2.1 Operadores L√≥gicos

| Operador | Significado | Exemplo |
| --- | --- | --- |
| `=` | Igual | `if Idade = 18 then` |
| `<>` | Diferente | `if Status <> 'Ativo' then` |
| `>` | Maior | `if Valor > 100 then` |
| `>=` | Maior ou igual | `if Nota >= 7.0 then` |
| `<` | Menor | `if Estoque < 10 then` |
| `<=` | Menor ou igual | `if Desconto <= 0.5 then` |
| `and` | E l√≥gico | `if (Idade >= 18) and (Ativo) then` |
| `or` | Ou l√≥gico | `if (Tipo = 'A') or (Tipo = 'B') then` |
| `not` | Nega√ß√£o | `if not Processado then` |

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uFrmConversao.pas
procedure TFrmConversao.ValidarParametros;
begin
  if (FConexaoOrigem = nil) or (FConexaoDestino = nil) then
    raise EExcecaoUsuario.Create('Conex√µes n√£o foram configuradas!');

  if (txtEmpresaOrigem.Text = '') and (txtEmpresaDestino.Text = '') then
    raise EExcecaoUsuario.Create('Informe pelo menos uma empresa!');
end;

```

### 2.2 Operadores Matem√°ticos

| Operador | Opera√ß√£o | Exemplo |
| --- | --- | --- |
| `+` | Adi√ß√£o | `Total := Valor1 + Valor2;` |
| `-` | Subtra√ß√£o | `Desconto := Total - 50;` |
| `*` | Multiplica√ß√£o | `Area := Base * Altura;` |
| `/` | Divis√£o (real) | `Media := Soma / 4;` |
| `div` | Divis√£o (inteira) | `Metade := 10 div 2; // 5` |
| `mod` | Resto da divis√£o | `Resto := 10 mod 3; // 1` |

### Preced√™ncia de Operadores

1. `not` (nega√ß√£o)
2. , `/`, `div`, `mod`, `and`
3. `+`, , `or`
4. `=`, `<>`, `<`, `>`, `<=`, `>=`

```
// Sem par√™nteses - pode gerar confus√£o
var Resultado := 10 + 5 * 2; // = 20 (multiplica√ß√£o primeiro)

// ‚úÖ Com par√™nteses - mais claro
var Resultado := (10 + 5) * 2; // = 30

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// C√°lculo de desconto
procedure CalcularDesconto;
begin
  var ValorOriginal: Double := 100.0;
  var PercentualDesconto: Double := 0.15; // 15%
  var ValorDesconto: Double := ValorOriginal * PercentualDesconto;
  var ValorFinal: Double := ValorOriginal - ValorDesconto;

  ShowMessage(Format('Valor com desconto: R$ %.2f', [ValorFinal]));
end;

```

---

## 3. Estruturas de Decis√£o

### 3.1 IF / ELSE

```
// IF simples
if Idade >= 18 then
  ShowMessage('Maior de idade');

// IF com ELSE
if Estoque > 0 then
  ShowMessage('Produto dispon√≠vel')
else
  ShowMessage('Produto indispon√≠vel');

// IF aninhado
if Usuario.Ativo then
begin
  if Usuario.Tipo = 'Admin' then
    ShowMessage('Bem-vindo, Administrador!')
  else
    ShowMessage('Bem-vindo, Usu√°rio!');
end
else
  ShowMessage('Usu√°rio inativo');

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
function TBaseBuilder<T>.AddPrimaryKey(const CampoPKOrigem: string): IParametroSQL<T>;
begin
  if not Assigned(FParametroSQLAtual.TabelaConversao) then
    raise EExcecaoDesenvolvedor.Create(
      'Necess√°rio definir a tabela de convers√£o antes de adicionar chave prim√°ria!'
    );

  if CampoPKOrigem <> '' then
  begin
    FParametroSQLAtual.AdicionarCamposPk(
      FParametroSQLAtual.TabelaConversao.GetCampoPKDestino,
      CampoPKOrigem
    );
  end;

  Result := Self;
end;

```

### 3.2 CASE / OF (Switch)

```
case TipoUsuario of
  1: ShowMessage('Cliente');
  2: ShowMessage('Fornecedor');
  3: ShowMessage('Funcion√°rio');
else
  ShowMessage('Tipo desconhecido');
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Processamento por tipo de integra√ß√£o fiscal
procedure ProcessarIntegracaoFiscal(Tipo: TTipoIntegracaoFiscal);
begin
  case Tipo of
    tifSchmitt: ProcessarSchmitt;
    tifIMendes: ProcessarIMendes;
    tifMixFiscal: ProcessarMixFiscal;
  else
    raise Exception.Create('Tipo de integra√ß√£o fiscal n√£o suportado');
  end;
end;

```

---

## 4. Estruturas de Repeti√ß√£o (Loops)

### 4.1 FOR Loop

```
// FOR crescente
for var I: Integer := 0 to 10 do
  ShowMessage('Itera√ß√£o: ' + I.ToString);

// FOR decrescente
for var I: Integer := 10 downto 0 do
  ShowMessage('Contagem regressiva: ' + I.ToString);

// FOR com array
var Nomes: TArray<string> := ['Ana', 'Bruno', 'Carlos'];
for var Nome in Nomes do
  ShowMessage('Nome: ' + Nome);

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uConversao.TConversaoGenerica.pas
procedure ProcessarRegistros;
begin
  for var I: Integer := 0 to cdsOrigem.RecordCount - 1 do
  begin
    cdsOrigem.RecNo := I + 1;

    // Processar cada registro
    ProcessarRegistroAtual;

    // Atualizar progresso
    AtualizarProgresso(I + 1, cdsOrigem.RecordCount);
  end;
end;

```

### 4.2 WHILE Loop

```
var Contador: Integer := 0;
while Contador < 10 do
begin
  ShowMessage('Contador: ' + Contador.ToString);
  Inc(Contador); // Incrementa em 1
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Processamento de registros at√© encontrar condi√ß√£o
procedure ProcessarAteEncontrar;
begin
  cdsOrigem.First;
  while not cdsOrigem.Eof do
  begin
    if cdsOrigem.FieldByName('STATUS').AsString = 'PROCESSADO' then
      Break; // Sai do loop

    ProcessarRegistro;
    cdsOrigem.Next;
  end;
end;

```

### 4.3 REPEAT / UNTIL

```
var Tentativas: Integer := 0;
repeat
  Inc(Tentativas);
  TentarConexao;
until (Conectado) or (Tentativas >= 3);

```

### 4.4 BREAK e CONTINUE

```
// BREAK - Sai do loop
for var I: Integer := 0 to 100 do
begin
  if I = 50 then
    Break; // Para no 50
  ProcessarItem(I);
end;

// CONTINUE - Pula para pr√≥xima itera√ß√£o
for var I: Integer := 0 to 100 do
begin
  if I mod 2 = 0 then
    Continue; // Pula n√∫meros pares
  ProcessarImpar(I);
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Processar apenas registros v√°lidos
procedure ProcessarRegistrosValidos;
begin
  for var I: Integer := 0 to ListaProdutos.Count - 1 do
  begin
    var Produto := ListaProdutos[I];

    // Pular produtos inativos
    if not Produto.Ativo then
      Continue;

    // Parar se encontrar erro cr√≠tico
    if Produto.PrecoInvalido then
      Break;

    ProcessarProduto(Produto);
  end;
end;

```

---

## 5. Fun√ß√µes e Procedimentos

### 5.1 Diferen√ßa entre Function e Procedure

**Procedure:** N√£o retorna valor

```
procedure ExibirMensagem(const Texto: string);
begin
  ShowMessage(Texto);
end;

```

**Function:** Retorna um valor

```
function Somar(A, B: Integer): Integer;
begin
  Result := A + B;
end;

```

### 5.2 Par√¢metros

### Por Valor (Padr√£o)

```
procedure Incrementar(Valor: Integer);
begin
  Valor := Valor + 1; // N√£o afeta vari√°vel original
end;

var X: Integer := 10;
Incrementar(X);
// X ainda √© 10

```

### Por Refer√™ncia (var)

```
procedure Incrementar(var Valor: Integer);
begin
  Valor := Valor + 1; // Afeta vari√°vel original
end;

var X: Integer := 10;
Incrementar(X);
// X agora √© 11

```

### Par√¢metro Constante (const)

```
function CalcularDesconto(const ValorOriginal: Double;
  const Percentual: Double): Double;
begin
  // N√£o pode modificar ValorOriginal ou Percentual
  Result := ValorOriginal * (1 - Percentual);
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
function TBaseBuilder<T>.AddCampo(
  const CampoDestino, CampoOrigem: string;  // const - otimiza√ß√£o
  TabelaBuscar: ITabelaConversao;           // por valor (interface)
  const BuscarDinamico, Apelido: string;
  ExecutarFuncoes: TArray<TFuncoes>
): IParametroSQL<T>;
begin
  var Campo: TCamposConversao := TCamposConversao.Create;
  Campo.CampoDestino := CampoDestino;
  Campo.CampoOrigem := CampoOrigem;

  FParametroSQLAtual.ListaCampos.Add(Campo);
  Result := Self; // Retorna a pr√≥pria inst√¢ncia (fluent interface)
end;

```

### 5.3 Sobrecarga (Overload)

M√∫ltiplas vers√µes da mesma fun√ß√£o com par√¢metros diferentes:

```
// Vers√£o com 2 par√¢metros
function Somar(A, B: Integer): Integer; overload;
begin
  Result := A + B;
end;

// Vers√£o com 3 par√¢metros
function Somar(A, B, C: Integer): Integer; overload;
begin
  Result := A + B + C;
end;

// Uso
var Resultado1 := Somar(5, 10);      // Usa primeira vers√£o
var Resultado2 := Somar(5, 10, 15);  // Usa segunda vers√£o

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Diferentes vers√µes de convers√£o de pessoas
procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao); overload;
procedure ConversaoPessoas(
  ParametrosConversao: TParametrosConversao;
  ParametrosEndereco: TParametrosSubConversao
); overload;
procedure ConversaoPessoas(
  ParametrosConversao: TParametrosConversao;
  ParametrosEndereco: TParametrosSubConversao;
  ParametrosContatos: TParametrosSubConversao
); overload;

```

---

## 6. Trabalhando com Strings

### 6.1 Fun√ß√µes B√°sicas de String

```
var Texto: string := 'Sol.NET ERP';

// Tamanho da string
var Tamanho: Integer := Length(Texto); // 11

// Mai√∫sculas e min√∫sculas
var Maiuscula: string := UpperCase(Texto);   // 'SOL.NET ERP'
var Minuscula: string := LowerCase(Texto);   // 'sol.net erp'

// Posi√ß√£o de substring
var Posicao: Integer := Pos('NET', Texto);   // 5

// Copiar parte da string
var Parte: string := Copy(Texto, 1, 7);      // 'Sol.NET'

// Remover espa√ßos
var ComEspacos: string := '  Texto  ';
var SemEspacos: string := Trim(ComEspacos);  // 'Texto'

// Substituir texto
var NovoTexto: string := StringReplace(Texto, 'ERP', 'Sistema', []);

```

### 6.2 Concatena√ß√£o

```
// Operador +
var Nome: string := 'Jo√£o';
var Sobrenome: string := 'Silva';
var NomeCompleto: string := Nome + ' ' + Sobrenome;

// Format (mais profissional)
var Idade: Integer := 25;
var Mensagem: string := Format('%s tem %d anos', [Nome, Idade]);

// Concatena√ß√£o m√∫ltipla
var SQL: string := 'SELECT * FROM produtos ' +
                   'WHERE ativo = 1 ' +
                   'AND estoque > 0';

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Montagem de SQL din√¢mico
function MontarSQL: string;
begin
  var SQL: TStringBuilder := TStringBuilder.Create;
  try
    SQL.Append('SELECT ');
    SQL.Append('  p.ID_PRODUTO, ');
    SQL.Append('  p.DESCRICAO, ');
    SQL.Append('  p.PRECO ');
    SQL.Append('FROM PRODUTO p ');
    SQL.Append('WHERE p.ATIVO = 1 ');

    if FiltroCategoria <> '' then
      SQL.AppendFormat('  AND p.CATEGORIA = %s ', [QuotedStr(FiltroCategoria)]);

    Result := SQL.ToString;
  finally
    SQL.Free;
  end;
end;

```

### 6.3 QuotedStr - Muito Importante!

```
// ‚ùå ERRADO - Vulner√°vel a SQL Injection
var Nome: string := 'Jo√£o';
var SQL: string := 'SELECT * FROM clientes WHERE nome = ' + Nome;
// Gera: SELECT * FROM clientes WHERE nome = Jo√£o (ERRO!)

// ‚úÖ CORRETO - Usa QuotedStr
var SQL: string := 'SELECT * FROM clientes WHERE nome = ' + QuotedStr(Nome);
// Gera: SELECT * FROM clientes WHERE nome = 'Jo√£o'

```

---

## 7. Arrays e Listas

### 7.1 TArray<T> (Array Din√¢mico Gen√©rico)

```
// Declara√ß√£o e inicializa√ß√£o
var Numeros: TArray<Integer> := [1, 2, 3, 4, 5];
var Nomes: TArray<string> := ['Ana', 'Bruno', 'Carlos'];

// Definir tamanho dinamicamente
var Lista: TArray<Integer>;
SetLength(Lista, 10);

// Acessar elementos
Lista[0] := 100;
var Valor := Lista[0];

// Iterar
for var Numero in Numeros do
  ShowMessage(Numero.ToString);

```

### 7.2 TList<T> (Lista Gen√©rica)

```
uses System.Generics.Collections;

var ListaNomes: TList<string> := TList<string>.Create;
try
  // Adicionar
  ListaNomes.Add('Ana');
  ListaNomes.Add('Bruno');
  ListaNomes.Add('Carlos');

  // Acessar
  var Primeiro: string := ListaNomes[0];
  var Quantidade: Integer := ListaNomes.Count;

  // Remover
  ListaNomes.Delete(1);        // Remove 'Bruno'
  ListaNomes.Remove('Carlos'); // Remove por valor

  // Verificar exist√™ncia
  if ListaNomes.Contains('Ana') then
    ShowMessage('Ana est√° na lista');

  // Limpar
  ListaNomes.Clear;
finally
  ListaNomes.Free;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em Integracao.Tipos.pas
type
  TListaCallbacks = class(TObjectList<TCallbackConversao>)
  public
    procedure ExecutarCallbacks(Momento: TMomentoConversao;
      Conversao: TObject);
  end;

procedure TListaCallbacks.ExecutarCallbacks(
  Momento: TMomentoConversao;
  Conversao: TObject
);
begin
  for var Callback in Self do
  begin
    if Callback.Momento = Momento then
      Callback.Proc(Conversao);
  end;
end;

```

### 7.3 TClientDataSet (Dataset em Mem√≥ria)

Muito usado no [Sol.NET](http://sol.net/) para manipula√ß√£o de dados:

```
var cds: TClientDataSet := TClientDataSet.Create(nil);
try
  // Criar estrutura
  cds.FieldDefs.Add('ID', ftInteger);
  cds.FieldDefs.Add('NOME', ftString, 100);
  cds.FieldDefs.Add('PRECO', ftFloat);
  cds.CreateDataSet;

  // Inserir registro
  cds.Append;
  cds.FieldByName('ID').AsInteger := 1;
  cds.FieldByName('NOME').AsString := 'Produto A';
  cds.FieldByName('PRECO').AsFloat := 10.50;
  cds.Post;

  // Navegar
  cds.First;
  while not cds.Eof do
  begin
    var Nome := cds.FieldByName('NOME').AsString;
    ShowMessage(Nome);
    cds.Next;
  end;

  // Localizar (importante no Sol.NET)
  if cds.Locate('ID', 1, []) then
    ShowMessage('Encontrado!');
finally
  cds.Free;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Fun√ß√£o LocalizarBin√°rio (melhor performance)
function LocalizarBinario(
  cds: TClientDataSet;
  const Campo: string;
  const Valor: Variant
): Boolean;
begin
  // Dataset DEVE estar ordenado pelo campo
  cds.IndexFieldNames := Campo;
  Result := cds.FindKey([Valor]);
end;

```

Defini√ß√£o
Um vetor (ou array unidimensional) √© uma estrutura de dados que armazena uma cole√ß√£o sequencial de elementos do mesmo tipo, acess√≠veis por um √≠ndice num√©rico.

Sintaxe Delphi
// Declara√ß√£o est√°tica
var NomesClientes: array[0..9] of string;

// Declara√ß√£o din√¢mica (tamanho vari√°vel)
var CodigosProdutos: TArray<Integer>;

// Declara√ß√£o inline (Delphi 12.2)
var ListaPrecos: TArray<Double> := [10.50, 25.00, 35.75];
Exemplos Pr√°ticos do Sol.NET
1. Array de Fun√ß√µes de Transforma√ß√£o (Convers√£o)
// Arquivo: uConversao.TiposAuxiliares.pas
type
  TFuncoes = (SoNumeros, RemoverAcentos, Maiuscula, Minuscula, 
              DataParaString, StringParaData, ValorParaString);

// Uso no Builder de Convers√£o
.AddCampo('CPF', 'CPF_CLIENTE', nil, '', '', [TFuncoes.SoNumeros])
.AddCampo('NOME', 'NOME_CLIENTE', nil, '', '', [TFuncoes.RemoverAcentos, TFuncoes.Maiuscula])
Explica√ß√£o: O array [TFuncoes.SoNumeros] armazena uma sequ√™ncia de transforma√ß√µes que ser√£o aplicadas ao campo durante a convers√£o.

2. Array de Campos para Concatena√ß√£o SQL
// Uso no Framework de Convers√£o
SQLOrigem.CONCAT(['EMPRESA', 'CODIGO', 'FILIAL'], '#')

// Resultado gerado automaticamente:
// SQL Server: EMPRESA + '#' + CODIGO + '#' + FILIAL
// Firebird: EMPRESA || '#' || CODIGO || '#' || FILIAL
Explica√ß√£o: O vetor ['EMPRESA', 'CODIGO', 'FILIAL'] armazena os nomes dos campos que ser√£o concatenados.

3. Array de Configura√ß√µes de Empresas
// Declara√ß√£o
var EmpresasAtivas: TArray<Integer>;

// Preenchimento din√¢mico
procedure CarregarEmpresasAtivas;
begin
  SetLength(EmpresasAtivas, 0); // Limpa o array
  
  var qry := TDados.Create.CriarQuery;
  try
    qry.SQL.Text := 'SELECT ID_EMPRESA FROM EMPRESAS WHERE INATIVO = 0';
    qry.Open;
    
    while not qry.Eof do
    begin
      SetLength(EmpresasAtivas, Length(EmpresasAtivas) + 1);
      EmpresasAtivas[High(EmpresasAtivas)] := qry.FieldByName('ID_EMPRESA').AsInteger;
      qry.Next;
    end;
  finally
    qry.Free;
  end;
end;
4. Array de Callbacks (Framework de Convers√£o)
// Arquivo: ConversaoBuilder.pas
type
  TArrayCallbacks = TArray<TCallbackConversao>;

// Uso
ParametrosConversao.ListaCallbacks.Add(ValidarCPF);
ParametrosConversao.ListaCallbacks.Add(ValidarEmail);
ParametrosConversao.ListaCallbacks.Add(NormalizarEndereco);

// Execu√ß√£o sequencial
for var Callback in ParametrosConversao.ListaCallbacks do
  Callback.Executar(Self);
# Vetores e Matrizes no Contexto do Sol.NET

## üìö Vis√£o Geral

No desenvolvimento Delphi do Sol.NET, vetores e matrizes s√£o estruturas fundamentais para manipula√ß√£o eficiente de dados. Este documento explica esses conceitos usando exemplos pr√°ticos do pr√≥prio sistema.

---

## üìä Vetores (Arrays)

### Defini√ß√£o
Um **vetor** (ou array unidimensional) √© uma estrutura de dados que armazena uma cole√ß√£o sequencial de elementos do mesmo tipo, acess√≠veis por um √≠ndice num√©rico.

### Sintaxe Delphi
```delphi
// Declara√ß√£o est√°tica
var NomesClientes: array[0..9] of string;

// Declara√ß√£o din√¢mica (tamanho vari√°vel)
var CodigosProdutos: TArray<Integer>;

// Declara√ß√£o inline (Delphi 12.2)
var ListaPrecos: TArray<Double> := [10.50, 25.00, 35.75];
```

### Exemplos Pr√°ticos do Sol.NET

#### 1. Array de Fun√ß√µes de Transforma√ß√£o (Convers√£o)
```delphi
// Arquivo: uConversao.TiposAuxiliares.pas
type
  TFuncoes = (SoNumeros, RemoverAcentos, Maiuscula, Minuscula, 
              DataParaString, StringParaData, ValorParaString);

// Uso no Builder de Convers√£o
.AddCampo('CPF', 'CPF_CLIENTE', nil, '', '', [TFuncoes.SoNumeros])
.AddCampo('NOME', 'NOME_CLIENTE', nil, '', '', [TFuncoes.RemoverAcentos, TFuncoes.Maiuscula])
```
**Explica√ß√£o:** O array `[TFuncoes.SoNumeros]` armazena uma sequ√™ncia de transforma√ß√µes que ser√£o aplicadas ao campo durante a convers√£o.

#### 2. Array de Campos para Concatena√ß√£o SQL
```delphi
// Uso no Framework de Convers√£o
SQLOrigem.CONCAT(['EMPRESA', 'CODIGO', 'FILIAL'], '#')

// Resultado gerado automaticamente:
// SQL Server: EMPRESA + '#' + CODIGO + '#' + FILIAL
// Firebird: EMPRESA || '#' || CODIGO || '#' || FILIAL
```
**Explica√ß√£o:** O vetor `['EMPRESA', 'CODIGO', 'FILIAL']` armazena os nomes dos campos que ser√£o concatenados.

#### 3. Array de Configura√ß√µes de Empresas
```delphi
// Declara√ß√£o
var EmpresasAtivas: TArray<Integer>;

// Preenchimento din√¢mico
procedure CarregarEmpresasAtivas;
begin
  SetLength(EmpresasAtivas, 0); // Limpa o array
  
  var qry := TDados.Create.CriarQuery;
  try
    qry.SQL.Text := 'SELECT ID_EMPRESA FROM EMPRESAS WHERE INATIVO = 0';
    qry.Open;
    
    while not qry.Eof do
    begin
      SetLength(EmpresasAtivas, Length(EmpresasAtivas) + 1);
      EmpresasAtivas[High(EmpresasAtivas)] := qry.FieldByName('ID_EMPRESA').AsInteger;
      qry.Next;
    end;
  finally
    qry.Free;
  end;
end;
```

#### 4. Array de Callbacks (Framework de Convers√£o)
```delphi
// Arquivo: ConversaoBuilder.pas
type
  TArrayCallbacks = TArray<TCallbackConversao>;

// Uso
ParametrosConversao.ListaCallbacks.Add(ValidarCPF);
ParametrosConversao.ListaCallbacks.Add(ValidarEmail);
ParametrosConversao.ListaCallbacks.Add(NormalizarEndereco);

// Execu√ß√£o sequencial
for var Callback in ParametrosConversao.ListaCallbacks do
  Callback.Executar(Self);
```

---

## üî≤ Matrizes (Arrays Bidimensionais)

### Defini√ß√£o
Uma **matriz** √© uma estrutura de dados bidimensional (linhas √ó colunas) que armazena elementos do mesmo tipo, acess√≠veis por dois √≠ndices.

### Sintaxe Delphi
```delphi
// Declara√ß√£o est√°tica
var TabelaPrecos: array[0..9, 0..4] of Double; // 10 linhas √ó 5 colunas

// Declara√ß√£o din√¢mica
var MatrizDados: TArray<TArray<Variant>>;

// Acesso
TabelaPrecos[2, 3] := 150.00; // Linha 2, Coluna 3
```

### Exemplos Pr√°ticos do Sol.NET

#### 1. Matriz de Mapeamento de Campos (Convers√£o)
```delphi
// Conceito: Matriz que mapeia campos origem ‚Üí destino com transforma√ß√µes

type
  TCampoMapeado = record
    Origem: string;
    Destino: string;
    Funcoes: TArray<TFuncoes>;
  end;

var MapeamentoCampos: TArray<TCampoMapeado>;

// Configura√ß√£o
SetLength(MapeamentoCampos, 3);
MapeamentoCampos[0] := TCampoMapeado.Create('CPF_CLIENTE', 'CPF', [TFuncoes.SoNumeros]);
MapeamentoCampos[1] := TCampoMapeado.Create('NOME_CLIENTE', 'NOME', [TFuncoes.Maiuscula]);
MapeamentoCampos[2] := TCampoMapeado.Create('EMAIL_CLIENTE', 'EMAIL', [TFuncoes.Minuscula]);

// Uso
for var i := 0 to High(MapeamentoCampos) do
  Builder.AddCampo(MapeamentoCampos[i].Destino, 
                   MapeamentoCampos[i].Origem, 
                   nil, '', '', 
                   MapeamentoCampos[i].Funcoes);
```

#### 2. Matriz de Pre√ßos por Tabela e Produto
```delpril
// Sistema de precifica√ß√£o com m√∫ltiplas tabelas
type
  TMatrizPrecos = array of array of Double; // [IdProduto, IdTabelaPreco]

var MatrizPrecos: TMatrizPrecos;

procedure CarregarMatrizPrecos(Produtos, Tabelas: TArray<Integer>);
begin
  SetLength(MatrizPrecos, Length(Produtos), Length(Tabelas));
  
  for var i := 0 to High(Produtos) do
    for var j := 0 to High(Tabelas) do
    begin
      var qry := TDados.Create.CriarQuery;
      try
        qry.SQL.Text := 'SELECT PRECO FROM PRODUTO_PRECO ' +
                        'WHERE ID_PRODUTO = :PROD AND ID_TABELA = :TAB';
        qry.ParamByName('PROD').AsInteger := Produtos[i];
        qry.ParamByName('TAB').AsInteger := Tabelas[j];
        qry.Open;
        
        MatrizPrecos[i, j] := qry.FieldByName('PRECO').AsFloat;
      finally
        qry.Free;
      end;
    end;
end;

// Consulta de pre√ßo
function ObterPreco(IdxProduto, IdxTabela: Integer): Double;
begin
  Result := MatrizPrecos[IdxProduto, IdxTabela];
end;
```

#### 3. Matriz de Tributa√ß√£o Estadual (Fiscal)
```delphi
// Framework de Integra√ß√µes Fiscais
type
  TTributacaoEstado = record
    UF: string;
    ICMS: Double;
    MVA: Double;
    Reducao: Double;
  end;

  TMatrizTributacao = array of array of TTributacaoEstado; 
  // [IdProduto, IdEstado]

var TributacaoNacional: TMatrizTributacao;

procedure CarregarTributacao(NCM: string);
begin
  // Preenche matriz com al√≠quotas por produto e UF
  var Produtos := BuscarProdutosPorNCM(NCM);
  var Estados := ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 
                  'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 
                  'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'];
  
  SetLength(TributacaoNacional, Length(Produtos), Length(Estados));
  
  for var i := 0 to High(Produtos) do
    for var j := 0 to Low(Estados) to High(Estados) do
      TributacaoNacional[i, j] := ConsultarProvedor(Produtos[i], Estados[j]);
end;
```

#### 4. Matriz de Status de Sincroniza√ß√£o (MonitorIntegra√ß√£o)
```delphi
// Controle de m√∫ltiplas integra√ß√µes √ó empresas
type
  TStatusSync = (ssAguardando, ssProcessando, ssSucesso, ssErro);
  
  TMatrizIntegracao = array of array of TStatusSync; 
  // [IdEmpresa, TipoIntegracao]

var StatusIntegracoes: TMatrizIntegracao;

procedure InicializarMonitoramento;
begin
  var Empresas := [1, 2, 5, 7, 10];
  var Integracoes := [tiIFood, tiWBuy, tiScanntech, tiHetoBank];
  
  SetLength(StatusIntegracoes, Length(Empresas), Length(Integracoes));
  
  // Inicializa todos como aguardando
  for var i := 0 to High(Empresas) do
    for var j := 0 to High(Integracoes) do
      StatusIntegracoes[i, j] := ssAguardando;
end;

procedure AtualizarStatus(IdxEmpresa, IdxIntegracao: Integer; 
                          NovoStatus: TStatusSync);
begin
  StatusIntegracoes[IdxEmpresa, IdxIntegracao] := NovoStatus;
  LogAdd(Format('Empresa %d - Integra√ß√£o %d: %s', 
                [IdxEmpresa, IdxIntegracao, GetEnumName(TypeInfo(TStatusSync), Ord(NovoStatus))]));
end;
```

---

## üîç Compara√ß√£o: Vetor vs Matriz no Sol.NET

| Aspecto | Vetor (Array 1D) | Matriz (Array 2D) |
|---------|------------------|-------------------|
| **Dimens√µes** | 1 (linear) | 2 (linhas √ó colunas) |
| **√çndices** | `Array[i]` | `Matriz[i, j]` |
| **Uso T√≠pico** | Listas simples, configura√ß√µes | Tabelas de relacionamento, c√°lculos complexos |
| **Exemplo Sol.NET** | Lista de callbacks | Pre√ßos produto√ótabela |
| **Performance** | Acesso O(1) | Acesso O(1) |
| **Mem√≥ria** | N elementos | N √ó M elementos |

---

## üìã Estruturas Especializadas no Sol.NET

### TArrayCamposConversao (Vetor Tipado)
```delphi
// Arquivo: uConversao.TiposAuxiliares.pas
type
  TArrayCamposConversao = class
  private
    FLista: TObjectList<TCamposConversao>;
  public
    function AddCampo(CampoDestino, CampoOrigem: string; 
                      TabelaBuscar: ITabelaConversao = nil;
                      BuscarDinamico: string = '';
                      Apelido: string = '';
                      ExecutarFuncoes: TArray<TFuncoes> = nil): TCamposConversao;
    
    property Lista: TObjectList<TCamposConversao> read FLista;
  end;
```
**Explica√ß√£o:** Encapsula um vetor din√¢mico de objetos `TCamposConversao` com m√©todos especializados para convers√£o de dados.

### TClientDataSet (Matriz em Mem√≥ria)
```delphi
// Uso comum no Sol.NET para datasets em mem√≥ria
var cdsClientes: TClientDataSet;

procedure CarregarClientes;
begin
  cdsClientes := TClientDataSet.Create(nil);
  cdsClientes.FieldDefs.Add('ID', ftInteger);
  cdsClientes.FieldDefs.Add('NOME', ftString, 100);
  cdsClientes.FieldDefs.Add('CPF', ftString, 14);
  cdsClientes.CreateDataSet;
  
  // Preencher dados (conceitualmente uma matriz)
  cdsClientes.Append;
  cdsClientes.FieldByName('ID').AsInteger := 1;
  cdsClientes.FieldByName('NOME').AsString := 'Jo√£o Silva';
  cdsClientes.FieldByName('CPF').AsString := '12345678900';
  cdsClientes.Post;
end;

// Localiza√ß√£o bin√°ria (otimiza√ß√£o para vetores ordenados)
if LocalizarBin√°rio(cdsClientes, 'ID', 1) then
  ShowMessage('Cliente encontrado!');
```

---

## ‚úÖ Boas Pr√°ticas no Sol.NET

### 1. Sempre use SetLength antes de popular arrays din√¢micos
```delphi
// ‚úÖ Correto
var Lista: TArray<string>;
SetLength(Lista, 10);
Lista[0] := 'Primeiro item';

// ‚ùå Errado - causar√° exce√ß√£o
var Lista: TArray<string>;
Lista[0] := 'Primeiro item'; // Index out of bounds
```

### 2. Prefira LocalizarBin√°rio para pesquisas em datasets ordenados
```delphi
// ‚úÖ Otimizado O(log n)
cdsClientes.IndexFieldNames := 'ID';
if LocalizarBin√°rio(cdsClientes, 'ID', 123) then
  ProcessarCliente;

// ‚ùå Menos eficiente O(n)
cdsClientes.First;
while not cdsClientes.Eof do
begin
  if cdsClientes.FieldByName('ID').AsInteger = 123 then
  begin
    ProcessarCliente;
    Break;
  end;
  cdsClientes.Next;
end;
```

### 3. Use declara√ß√£o inline quando poss√≠vel (Delphi 12.2)
```delphi
// ‚úÖ Moderno e conciso
var StatusPermitidos: TArray<Integer> := [0, 1, 5, 10];

// ‚úÖ Tamb√©m v√°lido, mas mais verboso
var StatusPermitidos: TArray<Integer>;
SetLength(StatusPermitidos, 4);
StatusPermitidos[0] := 0;
StatusPermitidos[1] := 1;
StatusPermitidos[2] := 5;
StatusPermitidos[3] := 10;
```

### 4. Libere mem√≥ria de arrays de objetos
```delphi
// ‚úÖ Correto - evita memory leak
var ListaObjetos: TObjectList<TCliente>;
ListaObjetos := TObjectList<TCliente>.Create(True); // OwnsObjects = True
try
  // Usar lista
finally
  ListaObjetos.Free; // Libera objetos automaticamente
end;

// ‚ùå Vazamento de mem√≥ria
var ListaObjetos: TList<TCliente>;
ListaObjetos := TList<TCliente>.Create;
// Objetos n√£o s√£o liberados automaticamente
ListaObjetos.Free; // Vazamento!
```

---

## üéØ Casos de Uso Avan√ßados

### Grid Din√¢mico de Produtos (Matriz Virtual)
```delphi
// Simula matriz usando TClientDataSet para interface de grades de produtos
procedure MontarGradePrecos;
var
  cdsProdutos: TClientDataSet;
  TabelasPreco: TArray<Integer>;
  Produtos: TArray<Integer>;
begin
  cdsProdutos := TClientDataSet.Create(nil);
  try
    // Define estrutura (1 campo fixo + N colunas din√¢micas)
    cdsProdutos.FieldDefs.Add('PRODUTO', ftString, 100);
    
    TabelasPreco := [1, 2, 3, 4, 5]; // IDs das tabelas
    
    for var IdTabela in TabelasPreco do
      cdsProdutos.FieldDefs.Add('PRECO_' + IdTabela.ToString, ftFloat);
    
    cdsProdutos.CreateDataSet;
    
    // Preenche dados (matriz conceitual)
    Produtos := [10, 20, 30];
    
    for var IdProduto in Produtos do
    begin
      cdsProdutos.Append;
      cdsProdutos.FieldByName('PRODUTO').AsString := 
        BuscarNomeProduto(IdProduto);
      
      for var IdTabela in TabelasPreco do
        cdsProdutos.FieldByName('PRECO_' + IdTabela.ToString).AsFloat :=
          ConsultarPreco(IdProduto, IdTabela);
      
      cdsProdutos.Post;
    end;
    
    // Vincular ao grid visual
    DataSource1.DataSet := cdsProdutos;
  finally
    // N√£o liberar aqui - DataSource controla lifecycle
  end;
end;
```

---

## üìñ Gloss√°rio de Termos

| Termo | Defini√ß√£o |
|-------|-----------|
| **Vetor (Array)** | Estrutura unidimensional indexada |
| **Matriz** | Estrutura bidimensional (linhas √ó colunas) |
| **Array Din√¢mico** | Tamanho definido em tempo de execu√ß√£o |
| **Array Est√°tico** | Tamanho fixo definido em compila√ß√£o |
| **√çndice** | Posi√ß√£o num√©rica de acesso ao elemento |
| **High()** | Fun√ß√£o que retorna o maior √≠ndice v√°lido |
| **Low()** | Fun√ß√£o que retorna o menor √≠ndice v√°lido |
| **SetLength()** | Redefine tamanho de array din√¢mico |

---
---

## 8. Classes e Objetos

### 8.1 Defini√ß√£o de Classe

```
type
  TProduto = class
  private
    FId: Integer;
    FDescricao: string;
    FPreco: Double;
  public
    constructor Create(Id: Integer; const Descricao: string; Preco: Double);
    destructor Destroy; override;

    property Id: Integer read FId write FId;
    property Descricao: string read FDescricao write FDescricao;
    property Preco: Double read FPreco write FPreco;

    function CalcularPrecoComDesconto(Percentual: Double): Double;
  end;

```

### 8.2 Implementa√ß√£o

```
constructor TProduto.Create(Id: Integer; const Descricao: string; Preco: Double);
begin
  inherited Create; // Chama construtor da classe pai (TObject)
  FId := Id;
  FDescricao := Descricao;
  FPreco := Preco;
end;

destructor TProduto.Destroy;
begin
  // Limpar recursos se necess√°rio
  inherited; // Sempre chamar no final
end;

function TProduto.CalcularPrecoComDesconto(Percentual: Double): Double;
begin
  Result := FPreco * (1 - Percentual);
end;

```

### 8.3 Cria√ß√£o e Uso de Objetos

```
procedure TestarProduto;
begin
  var Produto: TProduto := TProduto.Create(1, 'Mouse USB', 25.90);
  try
    ShowMessage('Produto: ' + Produto.Descricao);
    ShowMessage('Pre√ßo: R$ ' + FormatFloat('0.00', Produto.Preco));

    var PrecoComDesconto := Produto.CalcularPrecoComDesconto(0.10);
    ShowMessage('Com 10% desconto: R$ ' + FormatFloat('0.00', PrecoComDesconto));
  finally
    Produto.Free; // SEMPRE liberar mem√≥ria!
  end;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uConversao.TiposAuxiliares.pas
type
  TCamposConversao = class
  private
    FCampoDestino: string;
    FCampoOrigem: string;
    FTabelaBuscar: ITabelaConversao;
    FExecutarFuncoes: TArray<TFuncoes>;
  public
    property CampoDestino: string read FCampoDestino write FCampoDestino;
    property CampoOrigem: string read FCampoOrigem write FCampoOrigem;
    property TabelaBuscar: ITabelaConversao read FTabelaBuscar write FTabelaBuscar;
    property ExecutarFuncoes: TArray<TFuncoes> read FExecutarFuncoes write FExecutarFuncoes;
  end;

```

---

## 9. Construtores e Destrutores

### 9.1 Construtor Padr√£o

```
type
  TCliente = class
  private
    FNome: string;
    FAtivo: Boolean;
  public
    constructor Create; // Construtor sem par√¢metros
  end;

constructor TCliente.Create;
begin
  inherited;
  FNome := 'Novo Cliente';
  FAtivo := True;
end;

```

### 9.2 Construtores Parametrizados

```
type
  TCliente = class
  public
    constructor Create; overload;
    constructor Create(const Nome: string); overload;
    constructor Create(const Nome: string; Ativo: Boolean); overload;
  end;

constructor TCliente.Create;
begin
  inherited;
  FNome := 'Novo Cliente';
  FAtivo := True;
end;

constructor TCliente.Create(const Nome: string);
begin
  Create; // Chama o construtor sem par√¢metros
  FNome := Nome;
end;

constructor TCliente.Create(const Nome: string; Ativo: Boolean);
begin
  Create(Nome); // Chama o construtor com um par√¢metro
  FAtivo := Ativo;
end;

```

### 9.3 Destrutor

```
type
  TGerenciador = class
  private
    FLista: TList<string>;
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TGerenciador.Create;
begin
  inherited;
  FLista := TList<string>.Create;
end;

destructor TGerenciador.Destroy;
begin
  FLista.Free; // Liberar objetos criados
  inherited;   // SEMPRE chamar inherited no final
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
type
  TBaseBuilder<T: TParametrosConversao> = class(TInterfacedObject,
    IConversaoBuilder<T>, IParametroSQL<T>)
  private
    FParametrosConversao: T;
    FParametroSQLAtual: TParametroSQL;
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TBaseBuilder<T>.Create;
begin
  inherited;
  FParametrosConversao := T.Create(nil);
  FParametroSQLAtual := TParametroSQL.Create;
end;

destructor TBaseBuilder<T>.Destroy;
begin
  // FParametrosConversao ser√° liberado por quem chamou Build
  // FParametroSQLAtual j√° foi adicionado aos par√¢metros
  inherited;
end;

```

---

## 10. Encapsulamento

### 10.1 Modificadores de Acesso

```
type
  TPessoa = class
  strict private
    FSenha: string;  // S√≥ acess√≠vel dentro desta classe
  private
    FIdade: Integer; // Acess√≠vel nesta unit
  protected
    FNome: string;   // Acess√≠vel em classes filhas
  public
    FEmail: string;  // Acess√≠vel em qualquer lugar (evitar!)
  end;

```

### 10.2 Properties (Getters e Setters)

```
type
  TContaBancaria = class
  private
    FSaldo: Double;
    function GetSaldo: Double;
    procedure SetSaldo(const Value: Double);
  public
    property Saldo: Double read GetSaldo write SetSaldo;
  end;

function TContaBancaria.GetSaldo: Double;
begin
  // Pode adicionar l√≥gica antes de retornar
  LogAdd('Consultando saldo...');
  Result := FSaldo;
end;

procedure TContaBancaria.SetSaldo(const Value: Double);
begin
  // Valida√ß√£o antes de atribuir
  if Value < 0 then
    raise Exception.Create('Saldo n√£o pode ser negativo!');
  FSaldo := Value;
end;

```

### 10.3 Property Somente Leitura

```
type
  TProduto = class
  private
    FId: Integer;
    FDescricao: string;
    FPreco: Double;
  public
    property Id: Integer read FId;  // Somente leitura
    property Descricao: string read FDescricao write FDescricao;
    property Preco: Double read FPreco write FPreco;
  end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em Integracao.Tipos.pas
type
  TResumoIntegracao = class
  private
    FRecebidos: Integer;
    FEnviados: Integer;
    FAtualizados: Integer;
    FExcluidos: Integer;
  public
    property Recebidos: Integer read FRecebidos;
    property Enviados: Integer read FEnviados;
    property Atualizados: Integer read FAtualizados;
    property Excluidos: Integer read FExcluidos;

    function IncRecebidos(Recebidos: Integer = 0): TResumoIntegracao;
    function ToString(ExibirZeros: Boolean = False): string; override;
  end;

```

---

## 11. Heran√ßa

### 11.1 Conceito B√°sico

```
// Classe base (pai)
type
  TAnimal = class
  protected
    FNome: string;
  public
    constructor Create(const Nome: string);
    procedure Comer; virtual;  // Pode ser sobrescrito
    property Nome: string read FNome write FNome;
  end;

// Classe derivada (filha)
type
  TCachorro = class(TAnimal)
  public
    procedure Latir;
    procedure Comer; override;  // Sobrescreve m√©todo da classe pai
  end;

constructor TAnimal.Create(const Nome: string);
begin
  inherited Create;
  FNome := Nome;
end;

procedure TAnimal.Comer;
begin
  ShowMessage(FNome + ' est√° comendo');
end;

procedure TCachorro.Latir;
begin
  ShowMessage(FNome + ' est√° latindo: Au au!');
end;

procedure TCachorro.Comer;
begin
  inherited; // Chama TAnimal.Comer primeiro
  ShowMessage('E abanando o rabo!');
end;

```

### 11.2 Virtual vs Override

- **virtual**: Marca m√©todo que PODE ser sobrescrito
- **override**: Sobrescreve m√©todo virtual da classe pai
- **reintroduce**: Cria nova implementa√ß√£o (n√£o sobrescreve)

```
type
  TBase = class
    procedure Metodo1; virtual;
    procedure Metodo2;
  end;

  TDerivada = class(TBase)
    procedure Metodo1; override;     // Sobrescreve
    procedure Metodo2; reintroduce;  // Nova implementa√ß√£o
  end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uFrmConversao.pas (classe base)
type
  TFrmConversao = class(TForm)
  protected
    procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao); virtual;
    procedure ConversaoProduto(ParametrosConversao: TParametrosConversao); virtual;
  end;

// Classes filhas espec√≠ficas de clientes
type
  TFrmConversaoCliente = class(TFrmConversao)
  protected
    procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao); override;
    // Adiciona l√≥gica espec√≠fica do cliente
  end;

```

### 11.3 Heran√ßa vs Composi√ß√£o

**Heran√ßa (√â UM):**

```
type
  TCarro = class(TVeiculo)  // Carro √â UM Ve√≠culo
  end;

```

**Composi√ß√£o (TEM UM):**

```
type
  TCarro = class
  private
    FMotor: TMotor;  // Carro TEM UM Motor
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TCarro.Create;
begin
  inherited;
  FMotor := TMotor.Create;
end;

destructor TCarro.Destroy;
begin
  FMotor.Free;
  inherited;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Composi√ß√£o em TIntegracaoBase
type
  TIntegracaoBase = class(TInterfacedObject, IIntegracaoBase)
  protected
    FDados: TDados;              // TEM UM objeto de dados
    FDadosBlob: TDados;          // TEM UM objeto de dados blob
    FOwner: TForm;               // TEM UM formul√°rio dono
  public
    constructor Create(Owner: TForm; Dados, DadosBlob: TDados);
  end;

```

---

## 12. Polimorfismo

### 12.1 Polimorfismo de Sobrescrita

```
type
  TForma = class
  public
    function CalcularArea: Double; virtual; abstract;
  end;

  TQuadrado = class(TForma)
  private
    FLado: Double;
  public
    constructor Create(Lado: Double);
    function CalcularArea: Double; override;
  end;

  TCirculo = class(TForma)
  private
    FRaio: Double;
  public
    constructor Create(Raio: Double);
    function CalcularArea: Double; override;
  end;

function TQuadrado.CalcularArea: Double;
begin
  Result := FLado * FLado;
end;

function TCirculo.CalcularArea: Double;
begin
  Result := Pi * FRaio * FRaio;
end;

// Uso polim√≥rfico
procedure ProcessarFormas;
begin
  var Formas: TList<TForma> := TList<TForma>.Create;
  try
    Formas.Add(TQuadrado.Create(5));
    Formas.Add(TCirculo.Create(3));

    for var Forma in Formas do
    begin
      // Chama o m√©todo correto dependendo do tipo real
      var Area := Forma.CalcularArea;
      ShowMessage('√Årea: ' + FormatFloat('0.00', Area));
    end;
  finally
    for var Forma in Formas do
      Forma.Free;
    Formas.Free;
  end;
end;

```

### 12.2 Upcasting e Downcasting

```
// Upcasting (impl√≠cito - sempre seguro)
var Cachorro: TCachorro := TCachorro.Create('Rex');
var Animal: TAnimal := Cachorro; // OK - Cachorro √© um Animal

// Downcasting (expl√≠cito - pode dar erro)
var Animal: TAnimal := TCachorro.Create('Rex');
var Cachorro: TCachorro := Animal as TCachorro; // Convers√£o for√ßada

// Verifica√ß√£o segura com 'is'
if Animal is TCachorro then
begin
  var Cachorro := TCachorro(Animal);
  Cachorro.Latir;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Polimorfismo com ITabelaConversao
type
  ITabelaConversao = interface
    function GetTabelaDestino: string;
    function GetTabelaAux: string;
    function GetCampoPKDestino: string;
  end;

  TTabelaPessoa = class(TInterfacedObject, ITabelaConversao)
  private
    FTipo: TTipoPessoa;
  public
    constructor Create(Tipo: TTipoPessoa);
    function GetTabelaDestino: string;
    function GetTabelaAux: string;
    function GetCampoPKDestino: string;
  end;

  TTabelaProduto = class(TInterfacedObject, ITabelaConversao)
  public
    function GetTabelaDestino: string;
    function GetTabelaAux: string;
    function GetCampoPKDestino: string;
  end;

// Uso polim√≥rfico
procedure ProcessarTabela(Tabela: ITabelaConversao);
begin
  var SQL := Format('SELECT * FROM %s', [Tabela.GetTabelaDestino]);
  QryExecutar(SQL);
end;

```

---

## 13. Classes Abstratas e Interfaces

### 13.1 Classes Abstratas

```
type
  // Classe abstrata - n√£o pode ser instanciada diretamente
  TProcessador = class abstract
  public
    procedure Inicializar; virtual; abstract;
    procedure Processar; virtual; abstract;
    procedure Finalizar; virtual; abstract;

    // M√©todo concreto (implementado)
    procedure Executar;
  end;

  TProcessadorPedidos = class(TProcessador)
  public
    procedure Inicializar; override;
    procedure Processar; override;
    procedure Finalizar; override;
  end;

procedure TProcessador.Executar;
begin
  Inicializar;
  try
    Processar;
  finally
    Finalizar;
  end;
end;

```

### 13.2 Interfaces

```
type
  // Interface - contrato puro
  IConexao = interface
    ['{12345678-1234-1234-1234-123456789012}']
    function Conectar: Boolean;
    procedure Desconectar;
    function Executar(const SQL: string): Boolean;
  end;

  // Implementa√ß√£o
  TConexaoFirebird = class(TInterfacedObject, IConexao)
  public
    function Conectar: Boolean;
    procedure Desconectar;
    function Executar(const SQL: string): Boolean;
  end;

```

### 13.3 Diferen√ßa: Classe Abstrata vs Interface

| Aspecto | Classe Abstrata | Interface |
| --- | --- | --- |
| Implementa√ß√£o | Pode ter m√©todos implementados | S√≥ assinaturas |
| Heran√ßa M√∫ltipla | N√£o | Sim |
| Campos | Pode ter | N√£o pode |
| Quando usar | Compartilhar c√≥digo | Definir contratos |

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Interface principal
type
  IIntegracaoBase = interface
    ['{1278E936-BCBB-43E9-9135-A613AED576C1}']
    function GetOwner: TForm;
    procedure IniciarTransacao(Principal: Boolean = True);
    procedure CommitTransacao(Principal: Boolean = True);
    procedure RollbackTransacao(Principal: Boolean = True);
    function BuscarConfigGerais(Config: string): string;
    procedure SalvarConfigGerais(Config, Valor: string);
  end;

// Interface estendida
  IIntegracaoPlataforma = interface(IIntegracaoBase)
    ['{71EF7637-9E9A-4A74-9922-A0A455178C30}']
    procedure SendMessage(mensagem: string);
    procedure Handshake(StatusIntegracao: TStatusIntegracao);
  end;

// Implementa√ß√£o base
  TIntegracaoBase = class(TInterfacedObject, IIntegracaoBase)
  protected
    FDados: TDados;
    FOwner: TForm;
  public
    constructor Create(Owner: TForm; Dados, DadosBlob: TDados);

    // Implementa√ß√£o dos m√©todos da interface
    function GetOwner: TForm;
    procedure IniciarTransacao(Principal: Boolean = True);
    // etc...
  end;

```
---

## 15. cliente data set [Sol.NET](http://sol.net/)
# Documenta√ß√£o T√©cnica: TClientDataSet no Sol.NET

## üìã Vis√£o Geral

O **TClientDataSet** √© um componente fundamental no Sol.NET para manipula√ß√£o de dados em mem√≥ria. Ele armazena o resultado de consultas ao banco de dados e fornece funcionalidades avan√ßadas de navega√ß√£o, filtragem, ordena√ß√£o e localiza√ß√£o de registros.

## üéØ Tipos de ClientDataSet no Sol.NET

O sistema Sol.NET utiliza principalmente dois tipos de TClientDataSet:

### 1. **cdsBuscar**
- **Prop√≥sito:** Armazenar resultados de consultas gerais
- **Uso comum:** Listagens, relat√≥rios, busca de dados
- **Escopo:** Vari√°vel local ou global dependendo do contexto

### 2. **cdsGeral** (Nomenclatura Vari√°vel)
- **Prop√≥sito:** Manipula√ß√£o de entidades espec√≠ficas do sistema
- **Exemplos:** `cdsProdutos`, `cdsPessoas`, `cdsMovimentos`
- **Uso comum:** CRUD de entidades, valida√ß√µes, processamentos

---

## üîç O que √© um TClientDataSet

### Defini√ß√£o
√â um objeto que armazena o resultado de uma consulta no banco de dados em mem√≥ria, funcionando como um conjunto de dados desconectado.

### Caracter√≠sticas Principais

‚úÖ **Armazena dados:** Mant√©m registros em mem√≥ria ap√≥s a consulta  
‚úÖ **Metadados:** Preserva nome das colunas, tipos de dados, √≠ndices  
‚úÖ **Navega√ß√£o:** Permite percorrer registros com cursores  
‚úÖ **Filtragem:** Suporta filtros locais sem nova consulta ao banco  
‚úÖ **Ordena√ß√£o:** Permite ordenar dados em mem√≥ria  
‚úÖ **Localiza√ß√£o:** Busca bin√°ria e sequencial de registros  

---

## üìä Estrutura e Metadados

### Informa√ß√µes Armazenadas

```delphi
// Quantidade de registros
var TotalRegistros: Integer := MeuCds.RecordCount;

// Nomes dos campos
var NomeCampo: string := MeuCds.Fields[0].FieldName;

// Tipo de dado de um campo
var TipoCampo: TFieldType := MeuCds.FieldByName('NOME').DataType;

// Verifica se h√° registros
var TemDados: Boolean := not MeuCds.IsEmpty;
```

---

## üîß Populando um TClientDataSet

### M√©todo Padr√£o no Sol.NET

```delphi
var strList: TStringList := TStringList.Create;
try
  strList.Add('SELECT         ');
  strList.Add('    FIRST 5 *  ');
  strList.Add('FROM           ');
  strList.Add('    CARGOS     ');
  strList.Add('ORDER BY       ');
  strList.Add('    DESCRICAO  ');
  
  cdsBuscar.Data := Dados.QryOpenOle(strList.Text);
finally
  strList.Free;
end;
```

### Exemplo com Par√¢metros

```delphi
var strSQL: TStringList := TStringList.Create;
try
  strSQL.Add('SELECT             ');
  strSQL.Add('    ID_PRODUTO,    ');
  strSQL.Add('    DESCRICAO,     ');
  strSQL.Add('    PRECO_VENDA    ');
  strSQL.Add('FROM               ');
  strSQL.Add('    PRODUTOS       ');
  strSQL.Add('WHERE              ');
  strSQL.Add('    INATIVO = 0    ');
  strSQL.Add('    AND PRECO_VENDA > ' + FloatToStr(PrecoMinimo));
  
  cdsProdutos.Data := Dados.QryOpenOle(strSQL.Text);
finally
  strSQL.Free;
end;
```

---

## üé≠ Acessando Valores dos Campos

### M√©todo B√°sico

```delphi
// Retorna Variant (pode ser null)
var Valor: Variant := MeuCds.FieldByName('NOME_COLUNA').Value;
```

### Convers√µes Tipadas (Seguras)

```delphi
// String
var Nome: string := MeuCds.FieldByName('NOME').AsString;

// Inteiro
var Codigo: Integer := MeuCds.FieldByName('CODIGO').AsInteger;

// Double/Currency
var Preco: Double := MeuCds.FieldByName('PRECO').AsFloat;

// Data/Hora
var DataCadastro: TDateTime := MeuCds.FieldByName('DATA_CADASTRO').AsDateTime;

// Boolean (campos 0/1)
var Ativo: Boolean := MeuCds.FieldByName('INATIVO').AsInteger = 0;
```

### Tratamento de Valores Nulos

```delphi
// Verificar se campo √© nulo
if MeuCds.FieldByName('EMAIL').IsNull then
  ShowMessage('Email n√£o informado');

// Valor padr√£o se nulo
var Email: string := IfThen(
  MeuCds.FieldByName('EMAIL').IsNull, 
  'sem-email@exemplo.com', 
  MeuCds.FieldByName('EMAIL').AsString
);
```

---

## üîÑ Navega√ß√£o entre Registros

### M√©todos de Movimenta√ß√£o

```delphi
// Move para o primeiro registro
MeuCds.First;

// Move para o √∫ltimo registro
MeuCds.Last;

// Pr√≥ximo registro
MeuCds.Next;

// Registro anterior
MeuCds.Prior;

// Move para um registro espec√≠fico (baseado em 0)
MeuCds.RecNo := 5;
```

### Verifica√ß√µes de Posi√ß√£o

```delphi
// Est√° no primeiro registro?
var NoPrimeiro: Boolean := MeuCds.Bof;

// Est√° no √∫ltimo registro?
var NoUltimo: Boolean := MeuCds.Eof;

// Est√° vazio?
var Vazio: Boolean := MeuCds.IsEmpty;

// Posi√ß√£o atual do cursor (baseado em 1)
var PosicaoAtual: Integer := MeuCds.RecNo;
```

### Loop Completo nos Registros

```delphi
// Padr√£o Clean Code
MeuCds.First;
while not MeuCds.Eof do
begin
  // Processar registro atual
  var Descricao: string := MeuCds.FieldByName('DESCRICAO').AsString;
  LogAdd(Format('Processando: %s', [Descricao]));
  
  // Avan√ßa para o pr√≥ximo
  MeuCds.Next;
end;
```

### Loop com Controle de √çndice

```delphi
var I: Integer;
MeuCds.First;
for I := 0 to MeuCds.RecordCount - 1 do
begin
  // Processar registro
  ProcessarRegistro(MeuCds);
  
  // N√£o precisa chamar Next no √∫ltimo registro
  if I < MeuCds.RecordCount - 1 then
    MeuCds.Next;
end;
```

---

## üîé Localiza√ß√£o de Registros

### M√©todo Preferencial: Busca Bin√°ria

**‚ö†Ô∏è Importante:** Para usar busca bin√°ria, o ClientDataSet **DEVE** estar ordenado pelo campo de busca.

```delphi
// Ordenar antes de localizar
MeuCds.IndexFieldNames := 'CODIGO';

// Localizar usando busca bin√°ria
if LocalizarBinario(MeuCds, 'CODIGO', CodigoBuscado) then
  ShowMessage('Registro encontrado!')
else
  ShowMessage('Registro n√£o encontrado.');
```

### Busca Sequencial (Locate)

```delphi
// Localizar por um campo
if MeuCds.Locate('EMAIL', 'usuario@exemplo.com', [loCaseInsensitive]) then
  ShowMessage('Email encontrado!');

// Localizar por m√∫ltiplos campos
if MeuCds.Locate('CODIGO;TIPO', VarArrayOf([123, 'A']), []) then
  ShowMessage('Registro encontrado!');
```

### Op√ß√µes de Localiza√ß√£o

```delphi
// Busca case insensitive
[loCaseInsensitive]

// Busca parcial (cont√©m)
[loPartialKey]

// Combina√ß√£o
[loCaseInsensitive, loPartialKey]
```

---

## üé® Filtragem de Dados

### Filtro Simples

```delphi
// Aplicar filtro
MeuCds.Filter := 'INATIVO = 0';
MeuCds.Filtered := True;

// Remover filtro
MeuCds.Filtered := False;
```

### Filtros Complexos

```delphi
// Com m√∫ltiplas condi√ß√µes
MeuCds.Filter := 'INATIVO = 0 AND PRECO_VENDA > 10.00';
MeuCds.Filtered := True;

// Com LIKE (SQL Server)
MeuCds.Filter := 'DESCRICAO LIKE ''%PRODUTO%''';
MeuCds.Filtered := True;

// Com IN
MeuCds.Filter := 'TIPO IN (''A'', ''B'', ''C'')';
MeuCds.Filtered := True;
```

### Filtro por Evento

```delphi
procedure TFrmMeuForm.ConfigurarFiltro;
begin
  MeuCds.OnFilterRecord := FiltrarPorPreco;
  MeuCds.Filtered := True;
end;

procedure TFrmMeuForm.FiltrarPorPreco(DataSet: TDataSet; var Accept: Boolean);
begin
  Accept := DataSet.FieldByName('PRECO_VENDA').AsFloat >= 100.00;
end;
```

---

## üìê Ordena√ß√£o de Dados

### Ordena√ß√£o Simples

```delphi
// Por um campo
MeuCds.IndexFieldNames := 'DESCRICAO';

// Ordem decrescente (SQL Server)
MeuCds.IndexFieldNames := 'PRECO_VENDA DESC';
```

### Ordena√ß√£o por M√∫ltiplos Campos

```delphi
MeuCds.IndexFieldNames := 'CATEGORIA;DESCRICAO';
```

### Ordena√ß√£o Customizada

```delphi
// Criar √≠ndice
MeuCds.AddIndex('IdxPrecoDesc', 'PRECO_VENDA', [ixDescending], '', '', 0);

// Usar √≠ndice
MeuCds.IndexName := 'IdxPrecoDesc';
```

---

## üõ†Ô∏è Manipula√ß√£o de Dados (CRUD)

### Inser√ß√£o

```delphi
MeuCds.Append;
try
  MeuCds.FieldByName('DESCRICAO').AsString := 'Novo Produto';
  MeuCds.FieldByName('PRECO_VENDA').AsFloat := 50.00;
  MeuCds.FieldByName('INATIVO').AsInteger := 0;
  MeuCds.Post;
except
  MeuCds.Cancel;
  raise;
end;
```

### Edi√ß√£o

```delphi
if MeuCds.Locate('ID_PRODUTO', 123, []) then
begin
  MeuCds.Edit;
  try
    MeuCds.FieldByName('PRECO_VENDA').AsFloat := 75.00;
    MeuCds.Post;
  except
    MeuCds.Cancel;
    raise;
  end;
end;
```

### Exclus√£o

```delphi
if MeuCds.Locate('ID_PRODUTO', 123, []) then
  MeuCds.Delete;
```

### Verificar Estado do Registro

```delphi
case MeuCds.State of
  dsInactive: // Inativo
  dsBrowse:   // Navega√ß√£o normal
  dsEdit:     // Em edi√ß√£o
  dsInsert:   // Em inser√ß√£o
end;
```

---

## üìä Agrega√ß√µes e C√°lculos

### Contadores e Totalizadores

```delphi
// Contar registros
var TotalProdutos: Integer := MeuCds.RecordCount;

// Somar valores
var TotalVendas: Double := 0;
MeuCds.First;
while not MeuCds.Eof do
begin
  TotalVendas := TotalVendas + MeuCds.FieldByName('VALOR_TOTAL').AsFloat;
  MeuCds.Next;
end;

// Calcular m√©dia
var MediaPrecos: Double := TotalVendas / MeuCds.RecordCount;
```

### Campos Calculados

```delphi
// Adicionar campo calculado
var CampoCalculado: TField := TFloatField.Create(MeuCds);
CampoCalculado.FieldName := 'TOTAL_COM_DESCONTO';
CampoCalculado.FieldKind := fkCalculated;
CampoCalculado.DataSet := MeuCds;

// Implementar c√°lculo
procedure TFrmMeuForm.MeuCdsCalcFields(DataSet: TDataSet);
begin
  var Subtotal: Double := DataSet.FieldByName('SUBTOTAL').AsFloat;
  var Desconto: Double := DataSet.FieldByName('DESCONTO').AsFloat;
  DataSet.FieldByName('TOTAL_COM_DESCONTO').AsFloat := Subtotal - Desconto;
end;
```

---

## üîÑ Sincroniza√ß√£o com Banco de Dados

### Aplicar Altera√ß√µes (ApplyUpdates)

```delphi
// Para DataSetProvider
if MeuCds.ChangeCount > 0 then
begin
  MeuCds.ApplyUpdates(0); // 0 = aplicar todas as altera√ß√µes
end;
```

### Cancelar Altera√ß√µes Pendentes

```delphi
MeuCds.CancelUpdates;
```

---

## üéØ Boas Pr√°ticas no Sol.NET

### 1. Ordena√ß√£o Antes de Localiza√ß√£o

```delphi
// ‚úÖ Correto
cdsProdutos.IndexFieldNames := 'ID_PRODUTO';
if LocalizarBinario(cdsProdutos, 'ID_PRODUTO', CodigoBuscado) then
  ProcessarProduto(cdsProdutos);

// ‚ùå Evitar (busca lenta)
if cdsProdutos.Locate('ID_PRODUTO', CodigoBuscado, []) then
  ProcessarProduto(cdsProdutos);
```

### 2. Libera√ß√£o de Recursos

```delphi
var strSQL: TStringList := TStringList.Create;
try
  strSQL.Add('SELECT * FROM PRODUTOS');
  cdsBuscar.Data := Dados.QryOpenOle(strSQL.Text);
  
  // Processar dados
  
finally
  strSQL.Free;
end;
```

### 3. Valida√ß√£o de Dados

```delphi
// Verificar se h√° dados antes de processar
if cdsBuscar.IsEmpty then
begin
  ShowMessage('Nenhum registro encontrado.');
  Exit;
end;

// Validar campo n√£o nulo
if cdsBuscar.FieldByName('EMAIL').IsNull then
  raise Exception.Create('Email √© obrigat√≥rio.');
```

### 4. Performance em Loops

```delphi
// ‚úÖ Desabilitar controles para melhor performance
cdsProdutos.DisableControls;
try
  cdsProdutos.First;
  while not cdsProdutos.Eof do
  begin
    ProcessarProduto(cdsProdutos);
    cdsProdutos.Next;
  end;
finally
  cdsProdutos.EnableControls;
end;
```

### 5. Nomenclatura Consistente

```delphi
// ‚úÖ Padr√µes do Sol.NET
cdsBuscar       // Consultas gerais
cdsProdutos     // Entidade espec√≠fica
cdsMovimentos   // Entidade espec√≠fica

// ‚ùå Evitar
cds1
ClientDataSet1
DataSet
```

---

## üö® Erros Comuns e Solu√ß√µes

### 1. "Dataset not in edit or insert mode"

```delphi
// ‚ùå Erro
MeuCds.FieldByName('NOME').AsString := 'Novo Nome';

// ‚úÖ Solu√ß√£o
MeuCds.Edit;
MeuCds.FieldByName('NOME').AsString := 'Novo Nome';
MeuCds.Post;
```

### 2. "Field not found"

```delphi
// ‚ùå Erro (nome incorreto)
var Valor := MeuCds.FieldByName('NOME_PRODUTO').AsString;

// ‚úÖ Solu√ß√£o (verificar nome exato)
var Valor := MeuCds.FieldByName('DESCRICAO').AsString;
```

### 3. Busca bin√°ria sem ordena√ß√£o

```delphi
// ‚ùå Erro (resultado imprevis√≠vel)
LocalizarBinario(MeuCds, 'CODIGO', 123);

// ‚úÖ Solu√ß√£o
MeuCds.IndexFieldNames := 'CODIGO';
LocalizarBinario(MeuCds, 'CODIGO', 123);
```

---

## üìö Refer√™ncia R√°pida

### Propriedades Importantes

| Propriedade | Descri√ß√£o |
|------------|-----------|
| `RecordCount` | N√∫mero total de registros |
| `RecNo` | Posi√ß√£o atual do cursor (1-based) |
| `Bof` | Est√° no in√≠cio? |
| `Eof` | Est√° no fim? |
| `IsEmpty` | Est√° vazio? |
| `State` | Estado atual (dsEdit, dsInsert, etc) |
| `FieldCount` | N√∫mero de campos |
| `Filter` | Express√£o de filtro |
| `Filtered` | Filtro ativo? |
| `IndexFieldNames` | Campos de ordena√ß√£o |

### M√©todos Principais

| M√©todo | Descri√ß√£o |
|--------|-----------|
| `First` | Vai para o primeiro registro |
| `Last` | Vai para o √∫ltimo registro |
| `Next` | Pr√≥ximo registro |
| `Prior` | Registro anterior |
| `Locate` | Busca sequencial |
| `Append` | Adiciona novo registro |
| `Edit` | Entra em modo de edi√ß√£o |
| `Post` | Confirma altera√ß√µes |
| `Cancel` | Cancela altera√ß√µes |
| `Delete` | Exclui registro atual |
| `DisableControls` | Desabilita atualiza√ß√£o visual |
| `EnableControls` | Habilita atualiza√ß√£o visual |

---

## üîó Documenta√ß√µes Relacionadas

- [Framework de Integra√ß√µes](./Framework%20Integracoes.md)
- [Sistema de Convers√£o](./Conversao/Documentacao%20Basica.md)
- Padr√µes de Desenvolvimento Clean Code

---

### O que √© um TClientDataSet
 
`√â o objeto que armazena o resultado de uma consulta no banco de dados.
Tamb√©m armazena os metadados da consulta (Nome das colunas e seus tipos de dados, quantidade de registros carregados, etc)`
 
`Retorna o valor de uma coluna da linha selecionada atrav√©s da chamada de cdsMeuCds.`FieldByName('NOME_DA_COLUNA'`).Value'. O Value pode ser convertido para um tipo espec√≠fico para fins de seguran√ßa de valores null, ex: FieldByName('NOME_DA_COLUNA').AsInteger, AsString, AsDateTime, AsString, etc`.
 
### Populando um TClientDataSet
 ```pascal
var strList: TStringList := TStringList.Create;
strList.Add('SELECT         ');
strList.Add('    FIRST 5 *  ');
strList.Add('FROM           ');
strList.Add('    cargos     ');
strList.Add('ORDER BY       ');
strList.Add('    descricao  ');
 
 
MeuCds.Data := Dados.QryOpenOle(strList.Text);
 ````
### Fazendo opera√ß√µes com o TClientDataSet

 ```pascal
while not MeuCds.Eof do
begin
	// Executa o c√≥digo necess√°rio, baseado na linha atual que o TClientDataSet est√° apontando
	ShowMessage(MeuCds.FieldByName('ID_CARGO').AsString);
	// Move o cursor para a pr√≥xima posi√ß√£o (caso ela exista)
	MeuCds.Next;
end;
````
Copilot said: # üìö Documenta√ß√£o: `cdsBuscar` e `cdsGeral` no
üìö Documenta√ß√£o: cdsBuscar e cdsGeral no Sol.NET
Vou explicar detalhadamente esses dois componentes fundamentais usados nos CRUDs do Sol.NET.

üîç 1. cdsBuscar - ClientDataSet de Busca
O que √©?
O cdsBuscar √© um TClientDataSet utilizado especificamente para opera√ß√µes de consulta e localiza√ß√£o de registros no banco de dados. Ele √© otimizado para:

‚úÖ Buscas r√°pidas em telas de pesquisa
‚úÖ Autocompletar em campos de lookup
‚úÖ Listagens filtradas
‚úÖ Localiza√ß√£o de registros para relacionamentos
Caracter√≠sticas Principais
delphi
// Declara√ß√£o t√≠pica
var cdsBuscar: TClientDataSet;

// Uso comum
cdsBuscar := TClientDataSet.Create(nil);
try
  cdsBuscar.Data := DadosPrincipal.QryOpenOle(
    'SELECT ID_PESSOA, NOME, CPF FROM PESSOAS WHERE ATIVO = 1'
  );
  
  // Localiza√ß√£o bin√°ria (mais eficiente)
  if LocalizarBin√°rio(cdsBuscar, 'ID_PESSOA', IdPessoa) then
    ShowMessage('Pessoa encontrada: ' + cdsBuscar.FieldByName('NOME').AsString);
finally
  cdsBuscar.Free;
end;
Quando Usar cdsBuscar?
Cen√°rio	Exemplo
Busca em telas de pesquisa	SELECT * FROM PRODUTOS WHERE DESCRICAO LIKE '%'+Texto+'%'
Autocompletar de campos	Carregar lista de clientes ao digitar nome
Valida√ß√£o de exist√™ncia	Verificar se CPF j√° est√° cadastrado
Montagem de combos/listas	Preencher dropdown de categorias
Lookup de relacionamentos	Buscar ID_PRODUTO a partir do c√≥digo de barras
Boas Pr√°ticas com cdsBuscar
delphi
// ‚úÖ CORRETO - Liberar mem√≥ria
var cdsBuscar: TClientDataSet := TClientDataSet.Create(nil);
try
  cdsBuscar.Data := DadosPrincipal.QryOpenOle('SELECT ...');
  // Usar o dataset
finally
  cdsBuscar.Free; // Sempre liberar
end;

// ‚úÖ CORRETO - Ordenar antes de LocalizarBin√°rio
cdsBuscar.IndexFieldNames := 'CODIGO';
if LocalizarBin√°rio(cdsBuscar, 'CODIGO', '12345') then
  ShowMessage('Produto encontrado!');

// ‚ùå EVITAR - N√£o liberar mem√≥ria
cdsBuscar := TClientDataSet.Create(nil);
cdsBuscar.Data := DadosPrincipal.QryOpenOle('SELECT ...');
// Faltou o Free ‚Üí Memory Leak!

// ‚ùå EVITAR - LocalizarBin√°rio sem ordena√ß√£o
if LocalizarBin√°rio(cdsBuscar, 'NOME', 'Jo√£o') then // Erro se n√£o estiver ordenado!
üóÇÔ∏è 2. cdsGeral - ClientDataSet Geral
O que √©?
O cdsGeral √© um TClientDataSet de uso gen√©rico e tempor√°rio, utilizado para:

‚úÖ Opera√ß√µes auxiliares e c√°lculos
‚úÖ Armazenamento tempor√°rio de dados
‚úÖ Manipula√ß√£o de dados antes de gravar no banco
‚úÖ Estruturas de dados complexas em mem√≥ria
Caracter√≠sticas Principais
delphi
// Uso t√≠pico em convers√µes
var cdsGeral: TClientDataSet := TClientDataSet.Create(nil);
try
  cdsGeral.Data := DadosOrigem.QryOpenOle(
    'SELECT * FROM TABELA_ORIGEM WHERE ID > 1000'
  );
  
  // Processar dados
  cdsGeral.First;
  while not cdsGeral.Eof do
  begin
    // Aplicar transforma√ß√µes
    var Nome := cdsGeral.FieldByName('NOME').AsString;
    var CPF := SoNumeros(cdsGeral.FieldByName('CPF').AsString);
    
    // Gravar no destino
    DadosDestino.QryExecutar(
      Format('INSERT INTO PESSOAS (NOME, CPF) VALUES (%s, %s)',
        [QuotedStr(Nome), QuotedStr(CPF)])
    );
    
    cdsGeral.Next;
  end;
finally
  cdsGeral.Free;
end;
Quando Usar cdsGeral?
Cen√°rio	Exemplo
Processamento em lote	Importar 1000 produtos de arquivo CSV
C√°lculos complexos	Totalizar vendas antes de gravar
Dados tempor√°rios	Armazenar itens do carrinho antes de finalizar venda
Transforma√ß√µes de dados	Aplicar regras de neg√≥cio em mem√≥ria
Preview antes de salvar	Mostrar dados para usu√°rio confirmar
Exemplo Pr√°tico - Convers√£o com cdsGeral
delphi
procedure ConverterClientes;
var
  cdsGeral: TClientDataSet;
  cdsBuscar: TClientDataSet;
begin
  cdsGeral := TClientDataSet.Create(nil);
  cdsBuscar := TClientDataSet.Create(nil);
  try
    // 1. Carregar dados da origem
    cdsGeral.Data := DadosOrigem.QryOpenOle(
      'SELECT CODIGO, NOME, CPF, ID_CIDADE FROM CLIENTES_LEGADO'
    );
    
    // 2. Carregar lookup de cidades (cdsBuscar)
    cdsBuscar.Data := DadosDestino.QryOpenOle(
      'SELECT ID_CIDADE, ID_CIDADE_NOVA FROM AUX_CIDADES'
    );
    cdsBuscar.IndexFieldNames := 'ID_CIDADE';
    
    // 3. Processar cada registro do cdsGeral
    cdsGeral.First;
    while not cdsGeral.Eof do
    begin
      var CPF := SoNumeros(cdsGeral.FieldByName('CPF').AsString);
      
      // Buscar novo ID da cidade usando cdsBuscar
      var IdCidadeNova: Integer := 0;
      if LocalizarBin√°rio(cdsBuscar, 'ID_CIDADE', 
         cdsGeral.FieldByName('ID_CIDADE').AsInteger) then
      begin
        IdCidadeNova := cdsBuscar.FieldByName('ID_CIDADE_NOVA').AsInteger;
      end;
      
      // Gravar no destino
      DadosDestino.QryExecutar(
        Format('INSERT INTO PESSOAS (NOME, CPF, ID_CIDADE) VALUES (%s, %s, %d)',
          [QuotedStr(cdsGeral.FieldByName('NOME').AsString),
           QuotedStr(CPF),
           IdCidadeNova])
      );
      
      cdsGeral.Next;
    end;
  finally
    cdsGeral.Free;
    cdsBuscar.Free;
  end;
end;
üÜö Diferen√ßas Entre cdsBuscar e cdsGeral
Aspecto	cdsBuscar	cdsGeral
Prop√≥sito	Busca e localiza√ß√£o	Processamento e manipula√ß√£o
Dados	Geralmente menor volume	Pode conter grandes volumes
Tempo de vida	Curto (busca pontual)	Pode ser mais longo (loop)
Modifica√ß√£o	Raramente modificado	Frequentemente modificado
Ordena√ß√£o	Quase sempre ordenado	Nem sempre precisa
Exemplo de uso	Localizar produto por c√≥digo	Processar 1000 vendas
üîß Padr√µes de Uso no Framework de Convers√£o
No TConversao (classe base)
delphi
type
  TConversao = class
  private
    FcdsOrigem: TClientDataSet;  // Equivalente ao cdsGeral (dados origem)
    FcdsDestino: TClientDataSet; // Dados do destino
  public
    procedure ExecutarConversao;
  end;

procedure TConversao.ExecutarConversao;
begin
  // FcdsOrigem atua como "cdsGeral"
  FcdsOrigem.Data := DadosOrigem.QryOpenOle(MontarSQLOrigem);
  
  FcdsOrigem.First;
  while not FcdsOrigem.Eof do
  begin
    // Processar registro
    ProcessarRegistro(FcdsOrigem);
    FcdsOrigem.Next;
  end;
end;
Exemplo com Ambos no Mesmo M√©todo
delphi
procedure ConverterProdutosComCategorias;
var
  cdsGeral: TClientDataSet;   // Produtos origem
  cdsBuscar: TClientDataSet;  // Categorias de/para
begin
  cdsGeral := TClientDataSet.Create(nil);
  cdsBuscar := TClientDataSet.Create(nil);
  try
    // Carregar produtos
    cdsGeral.Data := DadosOrigem.QryOpenOle(
      'SELECT ID, DESCRICAO, ID_CATEGORIA FROM PRODUTOS_ORIGEM'
    );
    
    // Carregar lookup de categorias
    cdsBuscar.Data := DadosDestino.QryOpenOle(
      'SELECT ID_CATEGORIA_ORIGEM, ID_CATEGORIA_DESTINO FROM AUX_CATEGORIAS'
    );
    cdsBuscar.IndexFieldNames := 'ID_CATEGORIA_ORIGEM';
    
    // Processar
    cdsGeral.First;
    while not cdsGeral.Eof do
    begin
      var IdCategoriaNova := 0;
      
      // Buscar categoria convertida
      if LocalizarBin√°rio(cdsBuscar, 'ID_CATEGORIA_ORIGEM',
         cdsGeral.FieldByName('ID_CATEGORIA').AsInteger) then
      begin
        IdCategoriaNova := cdsBuscar.FieldByName('ID_CATEGORIA_DESTINO').AsInteger;
      end;
      
      // Inserir produto
      DadosDestino.QryExecutar(
        Format('INSERT INTO PRODUTOS (DESCRICAO, ID_CATEGORIA) VALUES (%s, %d)',
          [QuotedStr(cdsGeral.FieldByName('DESCRICAO').AsString),
           IdCategoriaNova])
      );
      
      cdsGeral.Next;
    end;
  finally
    cdsGeral.Free;
    cdsBuscar.Free;
  end;
end;
‚úÖ Checklist de Boas Pr√°ticas
Para cdsBuscar:
 Sempre ordenar antes de usar LocalizarBin√°rio
 Liberar mem√≥ria com Free no finally
 Usar para buscas pontuais e r√°pidas
 Manter dados m√≠nimos necess√°rios (campos essenciais)
Para cdsGeral:
 Criar dentro de try/finally
 Usar para processamento em lote
 Validar se est√° vazio antes de processar (IsEmpty)
 Liberar ap√≥s processamento completo
Ambos:
 Nunca deixar datasets abertos desnecessariamente
 Usar vari√°veis locais quando poss√≠vel
 Documentar o prop√≥sito do dataset no c√≥digo
 Verificar campos existem antes de acessar
üéØ Resumo Executivo
Dataset	Analogia	Uso Principal
cdsBuscar	üìñ Dicion√°rio	"Procurar" informa√ß√£o espec√≠fica
cdsGeral	üì¶ Caixa de trabalho	"Processar" m√∫ltiplos itens
Regra de Ouro:

Use cdsBuscar para ENCONTRAR dados.
Use cdsGeral para PROCESSAR dados.




---

## 15. Boas Pr√°ticas no [Sol.NET](http://sol.net/)

### 14.1 Nomenclatura

```
// ‚úÖ CORRETO
type
  TProduto = class            // Classes: TPascalCase
  private
    FDescricao: string;       // Campos privados: F + PascalCase
    FPreco: Double;
  public
    property Descricao: string read FDescricao write FDescricao;
    function CalcularTotal(Quantidade: Integer): Double;
  end;

  IRepositorio = interface    // Interfaces: I + PascalCase
    procedure Salvar;
  end;

procedure ProcessarPedido;    // Procedures/Functions: PascalCase
var Total: Double := 0.0;     // Vari√°veis locais: PascalCase

const
  TAXA_PADRAO = 0.05;         // Constantes: UPPER_CASE

```

### 14.2 Try/Finally (Gerenciamento de Mem√≥ria)

```
// ‚úÖ SEMPRE usar try/finally com objetos
procedure ProcessarDados;
begin
  var Lista: TList<string> := TList<string>.Create;
  try
    Lista.Add('Item 1');
    Lista.Add('Item 2');
    // Processar...
  finally
    Lista.Free;  // Garante libera√ß√£o mesmo com exce√ß√£o
  end;
end;

// ‚úÖ M√∫ltiplos objetos
procedure ProcessarMultiplos;
begin
  var Obj1: TObjecto1 := TObjecto1.Create;
  try
    var Obj2: TObjecto2 := TObjecto2.Create;
    try
      // Usar obj1 e obj2
    finally
      Obj2.Free;
    end;
  finally
    Obj1.Free;
  end;
end;

```

### 14.3 Tratamento de Exce√ß√µes Espec√≠ficas

```
// ‚úÖ Usar exce√ß√µes espec√≠ficas do Sol.NET
uses HetoExceptions, HetoExceptions.Conversao;

procedure ValidarDados;
begin
  if Usuario = '' then
    raise EExcecaoUsuario.Create('Usu√°rio n√£o informado!');

  if not Assigned(FDados) then
    raise EExcecaoDesenvolvedor.Create('Objeto FDados n√£o inicializado!');

  if not ValidarCPF(CPF) then
    raise EFalhaValidacao.Create('CPF inv√°lido: ' + CPF);
end;

```

### 14.4 SQL Seguro

```
// ‚ùå ERRADO - SQL Injection
procedure BuscarClienteErrado(Nome: string);
begin
  var SQL := 'SELECT * FROM PESSOA WHERE NOME = ' + Nome;
  QryExecutar(SQL);
end;

// ‚úÖ CORRETO - Com QuotedStr
procedure BuscarClienteCerto(Nome: string);
begin
  var SQL := 'SELECT * FROM PESSOA WHERE NOME = ' + QuotedStr(Nome);
  QryExecutar(SQL);
end;

// ‚úÖ MELHOR - Com par√¢metros (quando poss√≠vel)
procedure BuscarClienteMelhor(Nome: string);
begin
  Query.SQL.Text := 'SELECT * FROM PESSOA WHERE NOME = :NOME';
  Query.ParamByName('NOME').AsString := Nome;
  Query.Open;
end;

```

### 14.5 Logging

```
// ‚úÖ Sempre logar opera√ß√µes importantes
procedure ProcessarIntegracao;
begin
  LogAdd('Iniciando integra√ß√£o...');
  try
    // Processar
    LogAdd('Integra√ß√£o conclu√≠da com sucesso');
  except
    on E: Exception do
    begin
      LogAdd('ERRO: ' + E.Message);
      raise;
    end;
  end;
end;

```

### 14.6 Padr√£o Builder (Fluent Interface)

```
// ‚úÖ Usar interface fluente para configura√ß√£o
var Parametros := TConversaoBuilder.Create
  .SetTabelaConversao(TTabelaPessoa.Create(Pessoa), 'CLIENTES C')
  .AddPrimaryKey('C.CODIGO')
  .AddCampo('NOME', 'C.NOME_CLIENTE')
  .AddCampo('EMAIL', 'C.EMAIL')
  .AddWhere('C.ATIVO = ''S''')
  .Build;

```

### 14.7 Valida√ß√£o de Par√¢metros

```
// ‚úÖ Validar par√¢metros no in√≠cio dos m√©todos
function CalcularDesconto(ValorOriginal: Double; Percentual: Double): Double;
begin
  if ValorOriginal < 0 then
    raise EArgumentException.Create('Valor original n√£o pode ser negativo');

  if (Percentual < 0) or (Percentual > 1) then
    raise EArgumentException.Create('Percentual deve estar entre 0 e 1');

  Result := ValorOriginal * (1 - Percentual);
end;

```

### 14.8 Coment√°rios √öteis

```
// ‚úÖ Comentar PORQU√ä, n√£o O QUE
procedure ProcessarPedido;
begin
  // Necess√°rio ordenar antes de localizar (LocalizarBin√°rio exige)
  cdsProdutos.IndexFieldNames := 'ID_PRODUTO';

  if LocalizarBinario(cdsProdutos, 'ID_PRODUTO', IdProduto) then
  begin
    // Atualizar estoque aqui previne condi√ß√£o de corrida
    AtualizarEstoque;
  end;
end;

```

---

## üéì Exerc√≠cios Pr√°ticos

### Exerc√≠cio 1: Vari√°veis e Operadores

```
// Crie um procedimento que:
// 1. Declare vari√°veis inline para: Produto, Quantidade, Pre√ßo
// 2. Calcule o total
// 3. Aplique 10% de desconto se total > 100
// 4. Exiba o resultado

procedure CalcularPedido;
begin
  // SEU C√ìDIGO AQUI
end;

```

### Exerc√≠cio 2: Loops

```
// Percorra um TClientDataSet e:
// 1. Some todos os valores da coluna PRECO
// 2. Conte quantos produtos t√™m pre√ßo > 50
// 3. Exiba o resultado

procedure AnalisarProdutos(cdsProdutos: TClientDataSet);
begin
  // SEU C√ìDIGO AQUI
end;

```

### Exerc√≠cio 3: Classe Simples

```
// Crie uma classe TCliente com:
// 1. Campos privados: Id, Nome, Email
// 2. Propriedades p√∫blicas
// 3. M√©todo ValidarEmail que retorna Boolean
// 4. Constructor e Destructor

type
  TCliente = class
    // SEU C√ìDIGO AQUI
  end;

```

### Exerc√≠cio 4: Heran√ßa

```
// Crie hierarquia de classes:
// 1. TUsuario (base) com Nome, Login
// 2. TUsuarioAdmin (herda de TUsuario) com m√©todo CriarOutroUsuario
// 3. TUsuarioComum (herda de TUsuario) com m√©todo SolicitarPermissao

// SEU C√ìDIGO AQUI

```

---

## üìñ Recursos Adicionais

### Documenta√ß√£o Oficial

- [Embarcadero DocWiki](https://docwiki.embarcadero.com/)
- [Delphi Basics](http://www.delphibasics.co.uk/)

### Ferramentas √öteis

- **IDE Delphi 12.2**: Ambiente de desenvolvimento oficial
- **Git**: Controle de vers√£o
- **SQL Server Management Studio**: Gerenciamento de banco de dados

### Pr√≥ximos Passos

1. Estudar o c√≥digo existente em `Framework/`
2. Praticar com convers√µes simples
3. Implementar uma convers√£o completa supervisionada
4. Contribuir com melhorias no c√≥digo

---

## ‚úÖ Checklist de Conhecimento

Marque conforme for dominando cada t√≥pico:

### Fundamentos

- [ ]  Declara√ß√£o de vari√°veis inline
- [ ]  Uso de constantes
- [ ]  Operadores l√≥gicos e matem√°ticos
- [ ]  IF/ELSE e CASE
- [ ]  FOR, WHILE, REPEAT loops
- [ ]  BREAK e CONTINUE

### Fun√ß√µes e Strings

- [ ]  Procedures vs Functions
- [ ]  Par√¢metros por valor e refer√™ncia
- [ ]  Sobrecarga de m√©todos
- [ ]  Manipula√ß√£o de strings
- [ ]  QuotedStr para SQL

### Estruturas de Dados

- [ ]  TArray<T>
- [ ]  TList<T>
- [ ]  TClientDataSet
- [ ]  LocalizarBin√°rio

### POO - B√°sico

- [ ]  Cria√ß√£o de classes
- [ ]  Construtores e destrutores
- [ ]  Properties (get/set)
- [ ]  Encapsulamento (private/public)
- [ ]  Try/Finally para mem√≥ria

### POO - Avan√ßado

- [ ]  Heran√ßa (extends)
- [ ]  Virtual/Override
- [ ]  Polimorfismo
- [ ]  Classes abstratas
- [ ]  Interfaces
- [ ]  Composi√ß√£o vs Heran√ßa

### [Sol.NET](http://sol.net/) Espec√≠fico

- [ ]  Estrutura do projeto
- [ ]  Framework de Integra√ß√µes
- [ ]  Framework de Convers√£o
- [ ]  Padr√£o Builder
- [ ]  Exce√ß√µes customizadas
- [ ]  Logging e auditoria

---

## üéØ Conclus√£o

Este guia cobre os fundamentos essenciais para trabalhar com Delphi no contexto do [Sol.NET](http://sol.net/). Lembre-se:

1. **Pratique constantemente** - A melhor forma de aprender √© codificando
2. **Leia c√≥digo existente** - O [Sol.NET](http://sol.net/) tem muitos exemplos bem implementados
3. **Fa√ßa perguntas** - Sempre que tiver d√∫vidas, consulte a equipe
4. **Siga os padr√µes** - Clean Code e conven√ß√µes do projeto
5. **Teste seu c√≥digo** - Sempre valide antes de commitar

**Boa sorte nos estudos! üöÄ**

---

*√öltima atualiza√ß√£o: 23/10/2025*

*Vers√£o: 1.0*

*Respons√°vel: Equipe de Desenvolvimento [Sol.NET](http://sol.net/)*
