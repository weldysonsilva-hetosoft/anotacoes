# üìö Guia Completo de Programa√ß√£o Delphi para o [Sol.NE](http://sol.net/)T

## üéØ Sobre Este Guia

Este documento foi criado para desenvolvedores iniciantes e j√∫niores que est√£o come√ßando a trabalhar com o sistema [Sol.NET](http://sol.net/). Aqui voc√™ encontrar√° explica√ß√µes detalhadas sobre os conceitos fundamentais de programa√ß√£o em Delphi, com exemplos pr√°ticos extra√≠dos do pr√≥prio c√≥digo do [Sol.NET](http://sol.net/).

---

## üìë √çndice

1. [Vari√°veis e Constantes](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
2. [Operadores](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
3. [Estruturas de Decis√£o](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
4. [Estruturas de Repeti√ß√£o (Loops)](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
5. [Fun√ß√µes e Procedimentos](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
6. [Trabalhando com Strings](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
7. [Arrays e Listas](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
8. [Classes e Objetos](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
9. [Construtores e Destrutores](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
10. [Encapsulamento](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
11. [Heran√ßa](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
12. [Polimorfismo](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
13. [Classes Abstratas e Interfaces](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)
14. [Boas Pr√°ticas no Sol.NET](https://www.notion.so/Guia-Completo-de-Programa-o-Delphi-para-o-Sol-NET-2956d2e107ee80019d14e0449edb771e?pvs=21)

---

## 1. Vari√°veis e Constantes

### 1.1 Defini√ß√£o de Escopo

O **escopo** determina onde uma vari√°vel pode ser acessada no c√≥digo.

### Escopo Local

Vari√°veis declaradas dentro de um procedimento/fun√ß√£o s√≥ existem dentro dele.

```
procedure ExemploEscopoLocal;
begin
  var MinhaVariavel: Integer := 10; // Existe apenas dentro deste procedimento
  ShowMessage(MinhaVariavel.ToString);
end; // MinhaVariavel deixa de existir aqui

```

### Escopo Global (Campos de Classe)

Vari√°veis declaradas na se√ß√£o `private`, `protected` ou `public` de uma classe.

```
type
  TFrmConversao = class(TForm)
  private
    FNomeIntegracao: string; // Campo privado - acess√≠vel em toda a classe
    FDados: TDados;
  public
    property NomeIntegracao: string read FNomeIntegracao write FNomeIntegracao;
  end;

```

**Exemplo do [Sol.NET](http://sol.net/):**

```
// Em uFrmConversao.pas
type
  TFrmConversao = class(TForm)
  private
    FConexaoOrigem: TConexao;
    FConexaoDestino: TConexao;
    FControleUtilitarios: TControleUtilitarios;
  public
    procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao);
  end;

```

### 1.2 Tipos Mais Comuns

| Tipo | Descri√ß√£o | Exemplo |
| --- | --- | --- |
| `Integer` | N√∫meros inteiros (-2.147.483.648 a 2.147.483.647) | `var Idade: Integer := 25;` |
| `Double` | N√∫meros decimais | `var Preco: Double := 10.50;` |
| `String` | Texto | `var Nome: string := 'Jo√£o';` |
| `Boolean` | Verdadeiro ou Falso | `var Ativo: Boolean := True;` |
| `TDateTime` | Data e hora | `var DataAtual: TDateTime := Now;` |
| `Currency` | Valores monet√°rios | `var ValorTotal: Currency := 1500.75;` |

### 1.3 Declarando Vari√°veis (Padr√£o Inline)

No [Sol.NET](http://sol.net/), seguimos a conven√ß√£o de **declara√ß√£o inline** do Delphi 12.2:

```
// ‚úÖ CORRETO - Padr√£o Sol.NET
procedure ProcessarPedido;
begin
  var IdPedido: Integer := 1001;
  var NomeCliente: string := 'Maria Silva';
  var ValorTotal: Double := 0.0;
  var DataPedido: TDateTime := Now;

  // C√≥digo de processamento...
end;

```

```
// ‚ùå EVITAR - Padr√£o antigo
procedure ProcessarPedido;
var
  IdPedido: Integer;
  NomeCliente: string;
  ValorTotal: Double;
begin
  IdPedido := 1001;
  NomeCliente := 'Maria Silva';
  // ...
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
function TBaseBuilder<T>.AddCampo(
  const CampoDestino, CampoOrigem: string;
  TabelaBuscar: ITabelaConversao;
  const BuscarDinamico, Apelido: string;
  ExecutarFuncoes: TArray<TFuncoes>
): IParametroSQL<T>;
begin
  var Campo: TCamposConversao := TCamposConversao.Create;
  Campo.CampoDestino := CampoDestino;
  Campo.CampoOrigem := CampoOrigem;
  Campo.TabelaBuscar := TabelaBuscar;
  Campo.BuscarDinamico := BuscarDinamico;
  Campo.Apelido := Apelido;
  Campo.ExecutarFuncoes := ExecutarFuncoes;

  FParametroSQLAtual.ListaCampos.Add(Campo);
  Result := Self;
end;

```

### 1.4 Declarando Constantes

Constantes s√£o valores que n√£o podem ser alterados durante a execu√ß√£o.

```
const
  TAXA_PADRAO: Double = 0.05;
  NOME_SISTEMA: string = 'Sol.NET';
  VERSAO_MINIMA: Integer = 12;
  DIAS_SEMANA: array[0..6] of string = (
    'Domingo', 'Segunda', 'Ter√ßa', 'Quarta',
    'Quinta', 'Sexta', 'S√°bado'
  );

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Constantes de tipos de integra√ß√£o fiscal
const
  TIPO_SCHMITT = 'Schmitt';
  TIPO_IMENDES = 'IMendes';
  TIPO_MIXFISCAL = 'MixFiscal';

```

### 1.5 Declarando Arrays

### Array Est√°tico

```
var Notas: array[0..3] of Double := [7.5, 8.0, 9.2, 6.8];
var Nomes: array[0..2] of string := ['Ana', 'Bruno', 'Carlos'];

```

### Array Din√¢mico

```
var ListaIds: TArray<Integer>;
begin
  SetLength(ListaIds, 5);
  ListaIds[0] := 100;
  ListaIds[1] := 200;
  // ...
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em Integracao.Tipos.pas
type
  TArray<TFuncoes> = array of TFuncoes; // Array din√¢mico de fun√ß√µes

// Uso:
Campo.ExecutarFuncoes := [TFuncoes.SoNumeros, TFuncoes.Maiuscula];

```

---

## 2. Operadores

### 2.1 Operadores L√≥gicos

| Operador | Significado | Exemplo |
| --- | --- | --- |
| `=` | Igual | `if Idade = 18 then` |
| `<>` | Diferente | `if Status <> 'Ativo' then` |
| `>` | Maior | `if Valor > 100 then` |
| `>=` | Maior ou igual | `if Nota >= 7.0 then` |
| `<` | Menor | `if Estoque < 10 then` |
| `<=` | Menor ou igual | `if Desconto <= 0.5 then` |
| `and` | E l√≥gico | `if (Idade >= 18) and (Ativo) then` |
| `or` | Ou l√≥gico | `if (Tipo = 'A') or (Tipo = 'B') then` |
| `not` | Nega√ß√£o | `if not Processado then` |

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uFrmConversao.pas
procedure TFrmConversao.ValidarParametros;
begin
  if (FConexaoOrigem = nil) or (FConexaoDestino = nil) then
    raise EExcecaoUsuario.Create('Conex√µes n√£o foram configuradas!');

  if (txtEmpresaOrigem.Text = '') and (txtEmpresaDestino.Text = '') then
    raise EExcecaoUsuario.Create('Informe pelo menos uma empresa!');
end;

```

### 2.2 Operadores Matem√°ticos

| Operador | Opera√ß√£o | Exemplo |
| --- | --- | --- |
| `+` | Adi√ß√£o | `Total := Valor1 + Valor2;` |
| `-` | Subtra√ß√£o | `Desconto := Total - 50;` |
| `*` | Multiplica√ß√£o | `Area := Base * Altura;` |
| `/` | Divis√£o (real) | `Media := Soma / 4;` |
| `div` | Divis√£o (inteira) | `Metade := 10 div 2; // 5` |
| `mod` | Resto da divis√£o | `Resto := 10 mod 3; // 1` |

### Preced√™ncia de Operadores

1. `not` (nega√ß√£o)
2. , `/`, `div`, `mod`, `and`
3. `+`, , `or`
4. `=`, `<>`, `<`, `>`, `<=`, `>=`

```
// Sem par√™nteses - pode gerar confus√£o
var Resultado := 10 + 5 * 2; // = 20 (multiplica√ß√£o primeiro)

// ‚úÖ Com par√™nteses - mais claro
var Resultado := (10 + 5) * 2; // = 30

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// C√°lculo de desconto
procedure CalcularDesconto;
begin
  var ValorOriginal: Double := 100.0;
  var PercentualDesconto: Double := 0.15; // 15%
  var ValorDesconto: Double := ValorOriginal * PercentualDesconto;
  var ValorFinal: Double := ValorOriginal - ValorDesconto;

  ShowMessage(Format('Valor com desconto: R$ %.2f', [ValorFinal]));
end;

```

---

## 3. Estruturas de Decis√£o

### 3.1 IF / ELSE

```
// IF simples
if Idade >= 18 then
  ShowMessage('Maior de idade');

// IF com ELSE
if Estoque > 0 then
  ShowMessage('Produto dispon√≠vel')
else
  ShowMessage('Produto indispon√≠vel');

// IF aninhado
if Usuario.Ativo then
begin
  if Usuario.Tipo = 'Admin' then
    ShowMessage('Bem-vindo, Administrador!')
  else
    ShowMessage('Bem-vindo, Usu√°rio!');
end
else
  ShowMessage('Usu√°rio inativo');

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
function TBaseBuilder<T>.AddPrimaryKey(const CampoPKOrigem: string): IParametroSQL<T>;
begin
  if not Assigned(FParametroSQLAtual.TabelaConversao) then
    raise EExcecaoDesenvolvedor.Create(
      'Necess√°rio definir a tabela de convers√£o antes de adicionar chave prim√°ria!'
    );

  if CampoPKOrigem <> '' then
  begin
    FParametroSQLAtual.AdicionarCamposPk(
      FParametroSQLAtual.TabelaConversao.GetCampoPKDestino,
      CampoPKOrigem
    );
  end;

  Result := Self;
end;

```

### 3.2 CASE / OF (Switch)

```
case TipoUsuario of
  1: ShowMessage('Cliente');
  2: ShowMessage('Fornecedor');
  3: ShowMessage('Funcion√°rio');
else
  ShowMessage('Tipo desconhecido');
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Processamento por tipo de integra√ß√£o fiscal
procedure ProcessarIntegracaoFiscal(Tipo: TTipoIntegracaoFiscal);
begin
  case Tipo of
    tifSchmitt: ProcessarSchmitt;
    tifIMendes: ProcessarIMendes;
    tifMixFiscal: ProcessarMixFiscal;
  else
    raise Exception.Create('Tipo de integra√ß√£o fiscal n√£o suportado');
  end;
end;

```

---

## 4. Estruturas de Repeti√ß√£o (Loops)

### 4.1 FOR Loop

```
// FOR crescente
for var I: Integer := 0 to 10 do
  ShowMessage('Itera√ß√£o: ' + I.ToString);

// FOR decrescente
for var I: Integer := 10 downto 0 do
  ShowMessage('Contagem regressiva: ' + I.ToString);

// FOR com array
var Nomes: TArray<string> := ['Ana', 'Bruno', 'Carlos'];
for var Nome in Nomes do
  ShowMessage('Nome: ' + Nome);

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uConversao.TConversaoGenerica.pas
procedure ProcessarRegistros;
begin
  for var I: Integer := 0 to cdsOrigem.RecordCount - 1 do
  begin
    cdsOrigem.RecNo := I + 1;

    // Processar cada registro
    ProcessarRegistroAtual;

    // Atualizar progresso
    AtualizarProgresso(I + 1, cdsOrigem.RecordCount);
  end;
end;

```

### 4.2 WHILE Loop

```
var Contador: Integer := 0;
while Contador < 10 do
begin
  ShowMessage('Contador: ' + Contador.ToString);
  Inc(Contador); // Incrementa em 1
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Processamento de registros at√© encontrar condi√ß√£o
procedure ProcessarAteEncontrar;
begin
  cdsOrigem.First;
  while not cdsOrigem.Eof do
  begin
    if cdsOrigem.FieldByName('STATUS').AsString = 'PROCESSADO' then
      Break; // Sai do loop

    ProcessarRegistro;
    cdsOrigem.Next;
  end;
end;

```

### 4.3 REPEAT / UNTIL

```
var Tentativas: Integer := 0;
repeat
  Inc(Tentativas);
  TentarConexao;
until (Conectado) or (Tentativas >= 3);

```

### 4.4 BREAK e CONTINUE

```
// BREAK - Sai do loop
for var I: Integer := 0 to 100 do
begin
  if I = 50 then
    Break; // Para no 50
  ProcessarItem(I);
end;

// CONTINUE - Pula para pr√≥xima itera√ß√£o
for var I: Integer := 0 to 100 do
begin
  if I mod 2 = 0 then
    Continue; // Pula n√∫meros pares
  ProcessarImpar(I);
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Processar apenas registros v√°lidos
procedure ProcessarRegistrosValidos;
begin
  for var I: Integer := 0 to ListaProdutos.Count - 1 do
  begin
    var Produto := ListaProdutos[I];

    // Pular produtos inativos
    if not Produto.Ativo then
      Continue;

    // Parar se encontrar erro cr√≠tico
    if Produto.PrecoInvalido then
      Break;

    ProcessarProduto(Produto);
  end;
end;

```

---

## 5. Fun√ß√µes e Procedimentos

### 5.1 Diferen√ßa entre Function e Procedure

**Procedure:** N√£o retorna valor

```
procedure ExibirMensagem(const Texto: string);
begin
  ShowMessage(Texto);
end;

```

**Function:** Retorna um valor

```
function Somar(A, B: Integer): Integer;
begin
  Result := A + B;
end;

```

### 5.2 Par√¢metros

### Por Valor (Padr√£o)

```
procedure Incrementar(Valor: Integer);
begin
  Valor := Valor + 1; // N√£o afeta vari√°vel original
end;

var X: Integer := 10;
Incrementar(X);
// X ainda √© 10

```

### Por Refer√™ncia (var)

```
procedure Incrementar(var Valor: Integer);
begin
  Valor := Valor + 1; // Afeta vari√°vel original
end;

var X: Integer := 10;
Incrementar(X);
// X agora √© 11

```

### Par√¢metro Constante (const)

```
function CalcularDesconto(const ValorOriginal: Double;
  const Percentual: Double): Double;
begin
  // N√£o pode modificar ValorOriginal ou Percentual
  Result := ValorOriginal * (1 - Percentual);
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
function TBaseBuilder<T>.AddCampo(
  const CampoDestino, CampoOrigem: string;  // const - otimiza√ß√£o
  TabelaBuscar: ITabelaConversao;           // por valor (interface)
  const BuscarDinamico, Apelido: string;
  ExecutarFuncoes: TArray<TFuncoes>
): IParametroSQL<T>;
begin
  var Campo: TCamposConversao := TCamposConversao.Create;
  Campo.CampoDestino := CampoDestino;
  Campo.CampoOrigem := CampoOrigem;

  FParametroSQLAtual.ListaCampos.Add(Campo);
  Result := Self; // Retorna a pr√≥pria inst√¢ncia (fluent interface)
end;

```

### 5.3 Sobrecarga (Overload)

M√∫ltiplas vers√µes da mesma fun√ß√£o com par√¢metros diferentes:

```
// Vers√£o com 2 par√¢metros
function Somar(A, B: Integer): Integer; overload;
begin
  Result := A + B;
end;

// Vers√£o com 3 par√¢metros
function Somar(A, B, C: Integer): Integer; overload;
begin
  Result := A + B + C;
end;

// Uso
var Resultado1 := Somar(5, 10);      // Usa primeira vers√£o
var Resultado2 := Somar(5, 10, 15);  // Usa segunda vers√£o

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Diferentes vers√µes de convers√£o de pessoas
procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao); overload;
procedure ConversaoPessoas(
  ParametrosConversao: TParametrosConversao;
  ParametrosEndereco: TParametrosSubConversao
); overload;
procedure ConversaoPessoas(
  ParametrosConversao: TParametrosConversao;
  ParametrosEndereco: TParametrosSubConversao;
  ParametrosContatos: TParametrosSubConversao
); overload;

```

---

## 6. Trabalhando com Strings

### 6.1 Fun√ß√µes B√°sicas de String

```
var Texto: string := 'Sol.NET ERP';

// Tamanho da string
var Tamanho: Integer := Length(Texto); // 11

// Mai√∫sculas e min√∫sculas
var Maiuscula: string := UpperCase(Texto);   // 'SOL.NET ERP'
var Minuscula: string := LowerCase(Texto);   // 'sol.net erp'

// Posi√ß√£o de substring
var Posicao: Integer := Pos('NET', Texto);   // 5

// Copiar parte da string
var Parte: string := Copy(Texto, 1, 7);      // 'Sol.NET'

// Remover espa√ßos
var ComEspacos: string := '  Texto  ';
var SemEspacos: string := Trim(ComEspacos);  // 'Texto'

// Substituir texto
var NovoTexto: string := StringReplace(Texto, 'ERP', 'Sistema', []);

```

### 6.2 Concatena√ß√£o

```
// Operador +
var Nome: string := 'Jo√£o';
var Sobrenome: string := 'Silva';
var NomeCompleto: string := Nome + ' ' + Sobrenome;

// Format (mais profissional)
var Idade: Integer := 25;
var Mensagem: string := Format('%s tem %d anos', [Nome, Idade]);

// Concatena√ß√£o m√∫ltipla
var SQL: string := 'SELECT * FROM produtos ' +
                   'WHERE ativo = 1 ' +
                   'AND estoque > 0';

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Montagem de SQL din√¢mico
function MontarSQL: string;
begin
  var SQL: TStringBuilder := TStringBuilder.Create;
  try
    SQL.Append('SELECT ');
    SQL.Append('  p.ID_PRODUTO, ');
    SQL.Append('  p.DESCRICAO, ');
    SQL.Append('  p.PRECO ');
    SQL.Append('FROM PRODUTO p ');
    SQL.Append('WHERE p.ATIVO = 1 ');

    if FiltroCategoria <> '' then
      SQL.AppendFormat('  AND p.CATEGORIA = %s ', [QuotedStr(FiltroCategoria)]);

    Result := SQL.ToString;
  finally
    SQL.Free;
  end;
end;

```

### 6.3 QuotedStr - Muito Importante!

```
// ‚ùå ERRADO - Vulner√°vel a SQL Injection
var Nome: string := 'Jo√£o';
var SQL: string := 'SELECT * FROM clientes WHERE nome = ' + Nome;
// Gera: SELECT * FROM clientes WHERE nome = Jo√£o (ERRO!)

// ‚úÖ CORRETO - Usa QuotedStr
var SQL: string := 'SELECT * FROM clientes WHERE nome = ' + QuotedStr(Nome);
// Gera: SELECT * FROM clientes WHERE nome = 'Jo√£o'

```

---

## 7. Arrays e Listas

### 7.1 TArray<T> (Array Din√¢mico Gen√©rico)

```
// Declara√ß√£o e inicializa√ß√£o
var Numeros: TArray<Integer> := [1, 2, 3, 4, 5];
var Nomes: TArray<string> := ['Ana', 'Bruno', 'Carlos'];

// Definir tamanho dinamicamente
var Lista: TArray<Integer>;
SetLength(Lista, 10);

// Acessar elementos
Lista[0] := 100;
var Valor := Lista[0];

// Iterar
for var Numero in Numeros do
  ShowMessage(Numero.ToString);

```

### 7.2 TList<T> (Lista Gen√©rica)

```
uses System.Generics.Collections;

var ListaNomes: TList<string> := TList<string>.Create;
try
  // Adicionar
  ListaNomes.Add('Ana');
  ListaNomes.Add('Bruno');
  ListaNomes.Add('Carlos');

  // Acessar
  var Primeiro: string := ListaNomes[0];
  var Quantidade: Integer := ListaNomes.Count;

  // Remover
  ListaNomes.Delete(1);        // Remove 'Bruno'
  ListaNomes.Remove('Carlos'); // Remove por valor

  // Verificar exist√™ncia
  if ListaNomes.Contains('Ana') then
    ShowMessage('Ana est√° na lista');

  // Limpar
  ListaNomes.Clear;
finally
  ListaNomes.Free;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em Integracao.Tipos.pas
type
  TListaCallbacks = class(TObjectList<TCallbackConversao>)
  public
    procedure ExecutarCallbacks(Momento: TMomentoConversao;
      Conversao: TObject);
  end;

procedure TListaCallbacks.ExecutarCallbacks(
  Momento: TMomentoConversao;
  Conversao: TObject
);
begin
  for var Callback in Self do
  begin
    if Callback.Momento = Momento then
      Callback.Proc(Conversao);
  end;
end;

```

### 7.3 TClientDataSet (Dataset em Mem√≥ria)

Muito usado no [Sol.NET](http://sol.net/) para manipula√ß√£o de dados:

```
var cds: TClientDataSet := TClientDataSet.Create(nil);
try
  // Criar estrutura
  cds.FieldDefs.Add('ID', ftInteger);
  cds.FieldDefs.Add('NOME', ftString, 100);
  cds.FieldDefs.Add('PRECO', ftFloat);
  cds.CreateDataSet;

  // Inserir registro
  cds.Append;
  cds.FieldByName('ID').AsInteger := 1;
  cds.FieldByName('NOME').AsString := 'Produto A';
  cds.FieldByName('PRECO').AsFloat := 10.50;
  cds.Post;

  // Navegar
  cds.First;
  while not cds.Eof do
  begin
    var Nome := cds.FieldByName('NOME').AsString;
    ShowMessage(Nome);
    cds.Next;
  end;

  // Localizar (importante no Sol.NET)
  if cds.Locate('ID', 1, []) then
    ShowMessage('Encontrado!');
finally
  cds.Free;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Fun√ß√£o LocalizarBin√°rio (melhor performance)
function LocalizarBinario(
  cds: TClientDataSet;
  const Campo: string;
  const Valor: Variant
): Boolean;
begin
  // Dataset DEVE estar ordenado pelo campo
  cds.IndexFieldNames := Campo;
  Result := cds.FindKey([Valor]);
end;

```

---

## 8. Classes e Objetos

### 8.1 Defini√ß√£o de Classe

```
type
  TProduto = class
  private
    FId: Integer;
    FDescricao: string;
    FPreco: Double;
  public
    constructor Create(Id: Integer; const Descricao: string; Preco: Double);
    destructor Destroy; override;

    property Id: Integer read FId write FId;
    property Descricao: string read FDescricao write FDescricao;
    property Preco: Double read FPreco write FPreco;

    function CalcularPrecoComDesconto(Percentual: Double): Double;
  end;

```

### 8.2 Implementa√ß√£o

```
constructor TProduto.Create(Id: Integer; const Descricao: string; Preco: Double);
begin
  inherited Create; // Chama construtor da classe pai (TObject)
  FId := Id;
  FDescricao := Descricao;
  FPreco := Preco;
end;

destructor TProduto.Destroy;
begin
  // Limpar recursos se necess√°rio
  inherited; // Sempre chamar no final
end;

function TProduto.CalcularPrecoComDesconto(Percentual: Double): Double;
begin
  Result := FPreco * (1 - Percentual);
end;

```

### 8.3 Cria√ß√£o e Uso de Objetos

```
procedure TestarProduto;
begin
  var Produto: TProduto := TProduto.Create(1, 'Mouse USB', 25.90);
  try
    ShowMessage('Produto: ' + Produto.Descricao);
    ShowMessage('Pre√ßo: R$ ' + FormatFloat('0.00', Produto.Preco));

    var PrecoComDesconto := Produto.CalcularPrecoComDesconto(0.10);
    ShowMessage('Com 10% desconto: R$ ' + FormatFloat('0.00', PrecoComDesconto));
  finally
    Produto.Free; // SEMPRE liberar mem√≥ria!
  end;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uConversao.TiposAuxiliares.pas
type
  TCamposConversao = class
  private
    FCampoDestino: string;
    FCampoOrigem: string;
    FTabelaBuscar: ITabelaConversao;
    FExecutarFuncoes: TArray<TFuncoes>;
  public
    property CampoDestino: string read FCampoDestino write FCampoDestino;
    property CampoOrigem: string read FCampoOrigem write FCampoOrigem;
    property TabelaBuscar: ITabelaConversao read FTabelaBuscar write FTabelaBuscar;
    property ExecutarFuncoes: TArray<TFuncoes> read FExecutarFuncoes write FExecutarFuncoes;
  end;

```

---

## 9. Construtores e Destrutores

### 9.1 Construtor Padr√£o

```
type
  TCliente = class
  private
    FNome: string;
    FAtivo: Boolean;
  public
    constructor Create; // Construtor sem par√¢metros
  end;

constructor TCliente.Create;
begin
  inherited;
  FNome := 'Novo Cliente';
  FAtivo := True;
end;

```

### 9.2 Construtores Parametrizados

```
type
  TCliente = class
  public
    constructor Create; overload;
    constructor Create(const Nome: string); overload;
    constructor Create(const Nome: string; Ativo: Boolean); overload;
  end;

constructor TCliente.Create;
begin
  inherited;
  FNome := 'Novo Cliente';
  FAtivo := True;
end;

constructor TCliente.Create(const Nome: string);
begin
  Create; // Chama o construtor sem par√¢metros
  FNome := Nome;
end;

constructor TCliente.Create(const Nome: string; Ativo: Boolean);
begin
  Create(Nome); // Chama o construtor com um par√¢metro
  FAtivo := Ativo;
end;

```

### 9.3 Destrutor

```
type
  TGerenciador = class
  private
    FLista: TList<string>;
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TGerenciador.Create;
begin
  inherited;
  FLista := TList<string>.Create;
end;

destructor TGerenciador.Destroy;
begin
  FLista.Free; // Liberar objetos criados
  inherited;   // SEMPRE chamar inherited no final
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em ConversaoBuilder.pas
type
  TBaseBuilder<T: TParametrosConversao> = class(TInterfacedObject,
    IConversaoBuilder<T>, IParametroSQL<T>)
  private
    FParametrosConversao: T;
    FParametroSQLAtual: TParametroSQL;
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TBaseBuilder<T>.Create;
begin
  inherited;
  FParametrosConversao := T.Create(nil);
  FParametroSQLAtual := TParametroSQL.Create;
end;

destructor TBaseBuilder<T>.Destroy;
begin
  // FParametrosConversao ser√° liberado por quem chamou Build
  // FParametroSQLAtual j√° foi adicionado aos par√¢metros
  inherited;
end;

```

---

## 10. Encapsulamento

### 10.1 Modificadores de Acesso

```
type
  TPessoa = class
  strict private
    FSenha: string;  // S√≥ acess√≠vel dentro desta classe
  private
    FIdade: Integer; // Acess√≠vel nesta unit
  protected
    FNome: string;   // Acess√≠vel em classes filhas
  public
    FEmail: string;  // Acess√≠vel em qualquer lugar (evitar!)
  end;

```

### 10.2 Properties (Getters e Setters)

```
type
  TContaBancaria = class
  private
    FSaldo: Double;
    function GetSaldo: Double;
    procedure SetSaldo(const Value: Double);
  public
    property Saldo: Double read GetSaldo write SetSaldo;
  end;

function TContaBancaria.GetSaldo: Double;
begin
  // Pode adicionar l√≥gica antes de retornar
  LogAdd('Consultando saldo...');
  Result := FSaldo;
end;

procedure TContaBancaria.SetSaldo(const Value: Double);
begin
  // Valida√ß√£o antes de atribuir
  if Value < 0 then
    raise Exception.Create('Saldo n√£o pode ser negativo!');
  FSaldo := Value;
end;

```

### 10.3 Property Somente Leitura

```
type
  TProduto = class
  private
    FId: Integer;
    FDescricao: string;
    FPreco: Double;
  public
    property Id: Integer read FId;  // Somente leitura
    property Descricao: string read FDescricao write FDescricao;
    property Preco: Double read FPreco write FPreco;
  end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em Integracao.Tipos.pas
type
  TResumoIntegracao = class
  private
    FRecebidos: Integer;
    FEnviados: Integer;
    FAtualizados: Integer;
    FExcluidos: Integer;
  public
    property Recebidos: Integer read FRecebidos;
    property Enviados: Integer read FEnviados;
    property Atualizados: Integer read FAtualizados;
    property Excluidos: Integer read FExcluidos;

    function IncRecebidos(Recebidos: Integer = 0): TResumoIntegracao;
    function ToString(ExibirZeros: Boolean = False): string; override;
  end;

```

---

## 11. Heran√ßa

### 11.1 Conceito B√°sico

```
// Classe base (pai)
type
  TAnimal = class
  protected
    FNome: string;
  public
    constructor Create(const Nome: string);
    procedure Comer; virtual;  // Pode ser sobrescrito
    property Nome: string read FNome write FNome;
  end;

// Classe derivada (filha)
type
  TCachorro = class(TAnimal)
  public
    procedure Latir;
    procedure Comer; override;  // Sobrescreve m√©todo da classe pai
  end;

constructor TAnimal.Create(const Nome: string);
begin
  inherited Create;
  FNome := Nome;
end;

procedure TAnimal.Comer;
begin
  ShowMessage(FNome + ' est√° comendo');
end;

procedure TCachorro.Latir;
begin
  ShowMessage(FNome + ' est√° latindo: Au au!');
end;

procedure TCachorro.Comer;
begin
  inherited; // Chama TAnimal.Comer primeiro
  ShowMessage('E abanando o rabo!');
end;

```

### 11.2 Virtual vs Override

- **virtual**: Marca m√©todo que PODE ser sobrescrito
- **override**: Sobrescreve m√©todo virtual da classe pai
- **reintroduce**: Cria nova implementa√ß√£o (n√£o sobrescreve)

```
type
  TBase = class
    procedure Metodo1; virtual;
    procedure Metodo2;
  end;

  TDerivada = class(TBase)
    procedure Metodo1; override;     // Sobrescreve
    procedure Metodo2; reintroduce;  // Nova implementa√ß√£o
  end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Em uFrmConversao.pas (classe base)
type
  TFrmConversao = class(TForm)
  protected
    procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao); virtual;
    procedure ConversaoProduto(ParametrosConversao: TParametrosConversao); virtual;
  end;

// Classes filhas espec√≠ficas de clientes
type
  TFrmConversaoCliente = class(TFrmConversao)
  protected
    procedure ConversaoPessoas(ParametrosConversao: TParametrosConversao); override;
    // Adiciona l√≥gica espec√≠fica do cliente
  end;

```

### 11.3 Heran√ßa vs Composi√ß√£o

**Heran√ßa (√â UM):**

```
type
  TCarro = class(TVeiculo)  // Carro √â UM Ve√≠culo
  end;

```

**Composi√ß√£o (TEM UM):**

```
type
  TCarro = class
  private
    FMotor: TMotor;  // Carro TEM UM Motor
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TCarro.Create;
begin
  inherited;
  FMotor := TMotor.Create;
end;

destructor TCarro.Destroy;
begin
  FMotor.Free;
  inherited;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Composi√ß√£o em TIntegracaoBase
type
  TIntegracaoBase = class(TInterfacedObject, IIntegracaoBase)
  protected
    FDados: TDados;              // TEM UM objeto de dados
    FDadosBlob: TDados;          // TEM UM objeto de dados blob
    FOwner: TForm;               // TEM UM formul√°rio dono
  public
    constructor Create(Owner: TForm; Dados, DadosBlob: TDados);
  end;

```

---

## 12. Polimorfismo

### 12.1 Polimorfismo de Sobrescrita

```
type
  TForma = class
  public
    function CalcularArea: Double; virtual; abstract;
  end;

  TQuadrado = class(TForma)
  private
    FLado: Double;
  public
    constructor Create(Lado: Double);
    function CalcularArea: Double; override;
  end;

  TCirculo = class(TForma)
  private
    FRaio: Double;
  public
    constructor Create(Raio: Double);
    function CalcularArea: Double; override;
  end;

function TQuadrado.CalcularArea: Double;
begin
  Result := FLado * FLado;
end;

function TCirculo.CalcularArea: Double;
begin
  Result := Pi * FRaio * FRaio;
end;

// Uso polim√≥rfico
procedure ProcessarFormas;
begin
  var Formas: TList<TForma> := TList<TForma>.Create;
  try
    Formas.Add(TQuadrado.Create(5));
    Formas.Add(TCirculo.Create(3));

    for var Forma in Formas do
    begin
      // Chama o m√©todo correto dependendo do tipo real
      var Area := Forma.CalcularArea;
      ShowMessage('√Årea: ' + FormatFloat('0.00', Area));
    end;
  finally
    for var Forma in Formas do
      Forma.Free;
    Formas.Free;
  end;
end;

```

### 12.2 Upcasting e Downcasting

```
// Upcasting (impl√≠cito - sempre seguro)
var Cachorro: TCachorro := TCachorro.Create('Rex');
var Animal: TAnimal := Cachorro; // OK - Cachorro √© um Animal

// Downcasting (expl√≠cito - pode dar erro)
var Animal: TAnimal := TCachorro.Create('Rex');
var Cachorro: TCachorro := Animal as TCachorro; // Convers√£o for√ßada

// Verifica√ß√£o segura com 'is'
if Animal is TCachorro then
begin
  var Cachorro := TCachorro(Animal);
  Cachorro.Latir;
end;

```

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Polimorfismo com ITabelaConversao
type
  ITabelaConversao = interface
    function GetTabelaDestino: string;
    function GetTabelaAux: string;
    function GetCampoPKDestino: string;
  end;

  TTabelaPessoa = class(TInterfacedObject, ITabelaConversao)
  private
    FTipo: TTipoPessoa;
  public
    constructor Create(Tipo: TTipoPessoa);
    function GetTabelaDestino: string;
    function GetTabelaAux: string;
    function GetCampoPKDestino: string;
  end;

  TTabelaProduto = class(TInterfacedObject, ITabelaConversao)
  public
    function GetTabelaDestino: string;
    function GetTabelaAux: string;
    function GetCampoPKDestino: string;
  end;

// Uso polim√≥rfico
procedure ProcessarTabela(Tabela: ITabelaConversao);
begin
  var SQL := Format('SELECT * FROM %s', [Tabela.GetTabelaDestino]);
  QryExecutar(SQL);
end;

```

---

## 13. Classes Abstratas e Interfaces

### 13.1 Classes Abstratas

```
type
  // Classe abstrata - n√£o pode ser instanciada diretamente
  TProcessador = class abstract
  public
    procedure Inicializar; virtual; abstract;
    procedure Processar; virtual; abstract;
    procedure Finalizar; virtual; abstract;

    // M√©todo concreto (implementado)
    procedure Executar;
  end;

  TProcessadorPedidos = class(TProcessador)
  public
    procedure Inicializar; override;
    procedure Processar; override;
    procedure Finalizar; override;
  end;

procedure TProcessador.Executar;
begin
  Inicializar;
  try
    Processar;
  finally
    Finalizar;
  end;
end;

```

### 13.2 Interfaces

```
type
  // Interface - contrato puro
  IConexao = interface
    ['{12345678-1234-1234-1234-123456789012}']
    function Conectar: Boolean;
    procedure Desconectar;
    function Executar(const SQL: string): Boolean;
  end;

  // Implementa√ß√£o
  TConexaoFirebird = class(TInterfacedObject, IConexao)
  public
    function Conectar: Boolean;
    procedure Desconectar;
    function Executar(const SQL: string): Boolean;
  end;

```

### 13.3 Diferen√ßa: Classe Abstrata vs Interface

| Aspecto | Classe Abstrata | Interface |
| --- | --- | --- |
| Implementa√ß√£o | Pode ter m√©todos implementados | S√≥ assinaturas |
| Heran√ßa M√∫ltipla | N√£o | Sim |
| Campos | Pode ter | N√£o pode |
| Quando usar | Compartilhar c√≥digo | Definir contratos |

**Exemplo Real do [Sol.NET](http://sol.net/):**

```
// Interface principal
type
  IIntegracaoBase = interface
    ['{1278E936-BCBB-43E9-9135-A613AED576C1}']
    function GetOwner: TForm;
    procedure IniciarTransacao(Principal: Boolean = True);
    procedure CommitTransacao(Principal: Boolean = True);
    procedure RollbackTransacao(Principal: Boolean = True);
    function BuscarConfigGerais(Config: string): string;
    procedure SalvarConfigGerais(Config, Valor: string);
  end;

// Interface estendida
  IIntegracaoPlataforma = interface(IIntegracaoBase)
    ['{71EF7637-9E9A-4A74-9922-A0A455178C30}']
    procedure SendMessage(mensagem: string);
    procedure Handshake(StatusIntegracao: TStatusIntegracao);
  end;

// Implementa√ß√£o base
  TIntegracaoBase = class(TInterfacedObject, IIntegracaoBase)
  protected
    FDados: TDados;
    FOwner: TForm;
  public
    constructor Create(Owner: TForm; Dados, DadosBlob: TDados);

    // Implementa√ß√£o dos m√©todos da interface
    function GetOwner: TForm;
    procedure IniciarTransacao(Principal: Boolean = True);
    // etc...
  end;

```

---

## 14. Boas Pr√°ticas no [Sol.NET](http://sol.net/)

### 14.1 Nomenclatura

```
// ‚úÖ CORRETO
type
  TProduto = class            // Classes: TPascalCase
  private
    FDescricao: string;       // Campos privados: F + PascalCase
    FPreco: Double;
  public
    property Descricao: string read FDescricao write FDescricao;
    function CalcularTotal(Quantidade: Integer): Double;
  end;

  IRepositorio = interface    // Interfaces: I + PascalCase
    procedure Salvar;
  end;

procedure ProcessarPedido;    // Procedures/Functions: PascalCase
var Total: Double := 0.0;     // Vari√°veis locais: PascalCase

const
  TAXA_PADRAO = 0.05;         // Constantes: UPPER_CASE

```

### 14.2 Try/Finally (Gerenciamento de Mem√≥ria)

```
// ‚úÖ SEMPRE usar try/finally com objetos
procedure ProcessarDados;
begin
  var Lista: TList<string> := TList<string>.Create;
  try
    Lista.Add('Item 1');
    Lista.Add('Item 2');
    // Processar...
  finally
    Lista.Free;  // Garante libera√ß√£o mesmo com exce√ß√£o
  end;
end;

// ‚úÖ M√∫ltiplos objetos
procedure ProcessarMultiplos;
begin
  var Obj1: TObjecto1 := TObjecto1.Create;
  try
    var Obj2: TObjecto2 := TObjecto2.Create;
    try
      // Usar obj1 e obj2
    finally
      Obj2.Free;
    end;
  finally
    Obj1.Free;
  end;
end;

```

### 14.3 Tratamento de Exce√ß√µes Espec√≠ficas

```
// ‚úÖ Usar exce√ß√µes espec√≠ficas do Sol.NET
uses HetoExceptions, HetoExceptions.Conversao;

procedure ValidarDados;
begin
  if Usuario = '' then
    raise EExcecaoUsuario.Create('Usu√°rio n√£o informado!');

  if not Assigned(FDados) then
    raise EExcecaoDesenvolvedor.Create('Objeto FDados n√£o inicializado!');

  if not ValidarCPF(CPF) then
    raise EFalhaValidacao.Create('CPF inv√°lido: ' + CPF);
end;

```

### 14.4 SQL Seguro

```
// ‚ùå ERRADO - SQL Injection
procedure BuscarClienteErrado(Nome: string);
begin
  var SQL := 'SELECT * FROM PESSOA WHERE NOME = ' + Nome;
  QryExecutar(SQL);
end;

// ‚úÖ CORRETO - Com QuotedStr
procedure BuscarClienteCerto(Nome: string);
begin
  var SQL := 'SELECT * FROM PESSOA WHERE NOME = ' + QuotedStr(Nome);
  QryExecutar(SQL);
end;

// ‚úÖ MELHOR - Com par√¢metros (quando poss√≠vel)
procedure BuscarClienteMelhor(Nome: string);
begin
  Query.SQL.Text := 'SELECT * FROM PESSOA WHERE NOME = :NOME';
  Query.ParamByName('NOME').AsString := Nome;
  Query.Open;
end;

```

### 14.5 Logging

```
// ‚úÖ Sempre logar opera√ß√µes importantes
procedure ProcessarIntegracao;
begin
  LogAdd('Iniciando integra√ß√£o...');
  try
    // Processar
    LogAdd('Integra√ß√£o conclu√≠da com sucesso');
  except
    on E: Exception do
    begin
      LogAdd('ERRO: ' + E.Message);
      raise;
    end;
  end;
end;

```

### 14.6 Padr√£o Builder (Fluent Interface)

```
// ‚úÖ Usar interface fluente para configura√ß√£o
var Parametros := TConversaoBuilder.Create
  .SetTabelaConversao(TTabelaPessoa.Create(Pessoa), 'CLIENTES C')
  .AddPrimaryKey('C.CODIGO')
  .AddCampo('NOME', 'C.NOME_CLIENTE')
  .AddCampo('EMAIL', 'C.EMAIL')
  .AddWhere('C.ATIVO = ''S''')
  .Build;

```

### 14.7 Valida√ß√£o de Par√¢metros

```
// ‚úÖ Validar par√¢metros no in√≠cio dos m√©todos
function CalcularDesconto(ValorOriginal: Double; Percentual: Double): Double;
begin
  if ValorOriginal < 0 then
    raise EArgumentException.Create('Valor original n√£o pode ser negativo');

  if (Percentual < 0) or (Percentual > 1) then
    raise EArgumentException.Create('Percentual deve estar entre 0 e 1');

  Result := ValorOriginal * (1 - Percentual);
end;

```

### 14.8 Coment√°rios √öteis

```
// ‚úÖ Comentar PORQU√ä, n√£o O QUE
procedure ProcessarPedido;
begin
  // Necess√°rio ordenar antes de localizar (LocalizarBin√°rio exige)
  cdsProdutos.IndexFieldNames := 'ID_PRODUTO';

  if LocalizarBinario(cdsProdutos, 'ID_PRODUTO', IdProduto) then
  begin
    // Atualizar estoque aqui previne condi√ß√£o de corrida
    AtualizarEstoque;
  end;
end;

```

---

## üéì Exerc√≠cios Pr√°ticos

### Exerc√≠cio 1: Vari√°veis e Operadores

```
// Crie um procedimento que:
// 1. Declare vari√°veis inline para: Produto, Quantidade, Pre√ßo
// 2. Calcule o total
// 3. Aplique 10% de desconto se total > 100
// 4. Exiba o resultado

procedure CalcularPedido;
begin
  // SEU C√ìDIGO AQUI
end;

```

### Exerc√≠cio 2: Loops

```
// Percorra um TClientDataSet e:
// 1. Some todos os valores da coluna PRECO
// 2. Conte quantos produtos t√™m pre√ßo > 50
// 3. Exiba o resultado

procedure AnalisarProdutos(cdsProdutos: TClientDataSet);
begin
  // SEU C√ìDIGO AQUI
end;

```

### Exerc√≠cio 3: Classe Simples

```
// Crie uma classe TCliente com:
// 1. Campos privados: Id, Nome, Email
// 2. Propriedades p√∫blicas
// 3. M√©todo ValidarEmail que retorna Boolean
// 4. Constructor e Destructor

type
  TCliente = class
    // SEU C√ìDIGO AQUI
  end;

```

### Exerc√≠cio 4: Heran√ßa

```
// Crie hierarquia de classes:
// 1. TUsuario (base) com Nome, Login
// 2. TUsuarioAdmin (herda de TUsuario) com m√©todo CriarOutroUsuario
// 3. TUsuarioComum (herda de TUsuario) com m√©todo SolicitarPermissao

// SEU C√ìDIGO AQUI

```

---

## üìñ Recursos Adicionais

### Documenta√ß√£o Oficial

- [Embarcadero DocWiki](https://docwiki.embarcadero.com/)
- [Delphi Basics](http://www.delphibasics.co.uk/)

### Ferramentas √öteis

- **IDE Delphi 12.2**: Ambiente de desenvolvimento oficial
- **Git**: Controle de vers√£o
- **SQL Server Management Studio**: Gerenciamento de banco de dados

### Pr√≥ximos Passos

1. Estudar o c√≥digo existente em `Framework/`
2. Praticar com convers√µes simples
3. Implementar uma convers√£o completa supervisionada
4. Contribuir com melhorias no c√≥digo

---

## ‚úÖ Checklist de Conhecimento

Marque conforme for dominando cada t√≥pico:

### Fundamentos

- [ ]  Declara√ß√£o de vari√°veis inline
- [ ]  Uso de constantes
- [ ]  Operadores l√≥gicos e matem√°ticos
- [ ]  IF/ELSE e CASE
- [ ]  FOR, WHILE, REPEAT loops
- [ ]  BREAK e CONTINUE

### Fun√ß√µes e Strings

- [ ]  Procedures vs Functions
- [ ]  Par√¢metros por valor e refer√™ncia
- [ ]  Sobrecarga de m√©todos
- [ ]  Manipula√ß√£o de strings
- [ ]  QuotedStr para SQL

### Estruturas de Dados

- [ ]  TArray<T>
- [ ]  TList<T>
- [ ]  TClientDataSet
- [ ]  LocalizarBin√°rio

### POO - B√°sico

- [ ]  Cria√ß√£o de classes
- [ ]  Construtores e destrutores
- [ ]  Properties (get/set)
- [ ]  Encapsulamento (private/public)
- [ ]  Try/Finally para mem√≥ria

### POO - Avan√ßado

- [ ]  Heran√ßa (extends)
- [ ]  Virtual/Override
- [ ]  Polimorfismo
- [ ]  Classes abstratas
- [ ]  Interfaces
- [ ]  Composi√ß√£o vs Heran√ßa

### [Sol.NET](http://sol.net/) Espec√≠fico

- [ ]  Estrutura do projeto
- [ ]  Framework de Integra√ß√µes
- [ ]  Framework de Convers√£o
- [ ]  Padr√£o Builder
- [ ]  Exce√ß√µes customizadas
- [ ]  Logging e auditoria

---

## üéØ Conclus√£o

Este guia cobre os fundamentos essenciais para trabalhar com Delphi no contexto do [Sol.NET](http://sol.net/). Lembre-se:

1. **Pratique constantemente** - A melhor forma de aprender √© codificando
2. **Leia c√≥digo existente** - O [Sol.NET](http://sol.net/) tem muitos exemplos bem implementados
3. **Fa√ßa perguntas** - Sempre que tiver d√∫vidas, consulte a equipe
4. **Siga os padr√µes** - Clean Code e conven√ß√µes do projeto
5. **Teste seu c√≥digo** - Sempre valide antes de commitar

**Boa sorte nos estudos! üöÄ**

---

*√öltima atualiza√ß√£o: 23/10/2025*

*Vers√£o: 1.0*

*Respons√°vel: Equipe de Desenvolvimento [Sol.NET](http://sol.net/)*
